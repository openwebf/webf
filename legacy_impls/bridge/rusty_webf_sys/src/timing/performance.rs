// Generated by WebF TSDL, don't edit this file directly.
// Generate command: node scripts/generate_binding_code.js
/*
* Copyright (C) 2022-present The WebF authors. All rights reserved.
*/
use std::ffi::*;
use crate::*;
#[repr(C)]
enum PerformanceType {
  Performance = 0,
}
#[repr(C)]
pub struct PerformanceRustMethods {
  pub version: c_double,
  pub time_origin: extern "C" fn(*const OpaquePtr) -> i64,
  pub now: extern "C" fn(*const OpaquePtr, *const OpaquePtr) -> i64,
  pub webf_navigation_summary: extern "C" fn(*const OpaquePtr, *const OpaquePtr) -> AtomicStringRef,
  pub to_json: extern "C" fn(*const OpaquePtr, *const OpaquePtr) -> NativeValue,
  pub get_entries: extern "C" fn(*const OpaquePtr, *const OpaquePtr) -> VectorValueRef<PerformanceEntryRustMethods>,
  pub get_entries_by_type: extern "C" fn(*const OpaquePtr, *const c_char, *const OpaquePtr) -> VectorValueRef<PerformanceEntryRustMethods>,
  pub get_entries_by_name: extern "C" fn(*const OpaquePtr, *const c_char, *const c_char, *const OpaquePtr) -> VectorValueRef<PerformanceEntryRustMethods>,
  pub mark: extern "C" fn(*const OpaquePtr, *const c_char, *const PerformanceMarkOptions, *const OpaquePtr) -> c_void,
  pub measure: extern "C" fn(*const OpaquePtr, *const c_char, NativeValue, *const c_char, *const OpaquePtr) -> c_void,
  pub clear_marks: extern "C" fn(*const OpaquePtr, *const c_char, *const OpaquePtr) -> c_void,
  pub clear_measures: extern "C" fn(*const OpaquePtr, *const c_char, *const OpaquePtr) -> c_void,
  pub release: extern "C" fn(*const OpaquePtr) -> c_void,
  pub dynamic_to: extern "C" fn(*const OpaquePtr, type_: PerformanceType) -> RustValue<c_void>,
}
pub struct Performance {
  pub ptr: *const OpaquePtr,
  context: *const ExecutingContext,
  method_pointer: *const PerformanceRustMethods,
  status: *const RustValueStatus
}
impl Performance {
  pub fn initialize(ptr: *const OpaquePtr, context: *const ExecutingContext, method_pointer: *const PerformanceRustMethods, status: *const RustValueStatus) -> Performance {
    Performance {
      ptr,
      context,
      method_pointer,
      status
    }
  }
  pub fn ptr(&self) -> *const OpaquePtr {
    self.ptr
  }
  pub fn context<'a>(&self) -> &'a ExecutingContext {
    assert!(!self.context.is_null(), "Context PTR must not be null");
    unsafe { &*self.context }
  }
  pub fn time_origin(&self) -> i64 {
    let value = unsafe {
      ((*self.method_pointer).time_origin)(self.ptr())
    };
    value
  }
  pub fn now(&self, exception_state: &ExceptionState) -> Result<i64, String> {
    let value = unsafe {
      ((*self.method_pointer).now)(self.ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(value)
  }
  pub fn webf_navigation_summary(&self, exception_state: &ExceptionState) -> Result<String, String> {
    let value = unsafe {
      ((*self.method_pointer).webf_navigation_summary)(self.ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(value.to_string())
  }
  pub fn to_json(&self, exception_state: &ExceptionState) -> Result<NativeValue, String> {
    let value = unsafe {
      ((*self.method_pointer).to_json)(self.ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(value)
  }
  pub fn get_entries(&self, exception_state: &ExceptionState) -> Result<Vec<PerformanceEntry>, String> {
    let value = unsafe {
      ((*self.method_pointer).get_entries)(self.ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    let size = value.size as usize;
    let mut result = Vec::with_capacity(size);
    for i in 0..size {
      let value = unsafe { &*value.data.add(i) };
      let value = PerformanceEntry::initialize(value.value, self.context(), value.method_pointer, value.status);
      result.push(value);
    }
    Ok(result)
  }
  pub fn get_entries_by_type(&self, entry_type: &str, exception_state: &ExceptionState) -> Result<Vec<PerformanceEntry>, String> {
    let value = unsafe {
      ((*self.method_pointer).get_entries_by_type)(self.ptr(), CString::new(entry_type).unwrap().as_ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    let size = value.size as usize;
    let mut result = Vec::with_capacity(size);
    for i in 0..size {
      let value = unsafe { &*value.data.add(i) };
      let value = PerformanceEntry::initialize(value.value, self.context(), value.method_pointer, value.status);
      result.push(value);
    }
    Ok(result)
  }
  pub fn get_entries_by_name(&self, name: &str, type_: &str, exception_state: &ExceptionState) -> Result<Vec<PerformanceEntry>, String> {
    let value = unsafe {
      ((*self.method_pointer).get_entries_by_name)(self.ptr(), CString::new(name).unwrap().as_ptr(), CString::new(type_).unwrap().as_ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    let size = value.size as usize;
    let mut result = Vec::with_capacity(size);
    for i in 0..size {
      let value = unsafe { &*value.data.add(i) };
      let value = PerformanceEntry::initialize(value.value, self.context(), value.method_pointer, value.status);
      result.push(value);
    }
    Ok(result)
  }
  pub fn mark(&self, name: &str, options: &PerformanceMarkOptions, exception_state: &ExceptionState) -> Result<(), String> {
    unsafe {
      ((*self.method_pointer).mark)(self.ptr(), CString::new(name).unwrap().as_ptr(), options, exception_state.ptr);
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(())
  }
  pub fn measure(&self, name: &str, start_mark: NativeValue, end_mark: &str, exception_state: &ExceptionState) -> Result<(), String> {
    unsafe {
      ((*self.method_pointer).measure)(self.ptr(), CString::new(name).unwrap().as_ptr(), start_mark, CString::new(end_mark).unwrap().as_ptr(), exception_state.ptr);
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(())
  }
  pub fn clear_marks(&self, name: &str, exception_state: &ExceptionState) -> Result<(), String> {
    unsafe {
      ((*self.method_pointer).clear_marks)(self.ptr(), CString::new(name).unwrap().as_ptr(), exception_state.ptr);
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(())
  }
  pub fn clear_measures(&self, name: &str, exception_state: &ExceptionState) -> Result<(), String> {
    unsafe {
      ((*self.method_pointer).clear_measures)(self.ptr(), CString::new(name).unwrap().as_ptr(), exception_state.ptr);
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(())
  }
}
impl Drop for Performance {
  fn drop(&mut self) {
    unsafe {
      ((*self.method_pointer).release)(self.ptr());
    }
  }
}
pub trait PerformanceMethods {
  fn time_origin(&self) -> i64;
  fn now(&self, exception_state: &ExceptionState) -> Result<i64, String>;
  fn webf_navigation_summary(&self, exception_state: &ExceptionState) -> Result<String, String>;
  fn to_json(&self, exception_state: &ExceptionState) -> Result<NativeValue, String>;
  fn get_entries(&self, exception_state: &ExceptionState) -> Result<Vec<PerformanceEntry>, String>;
  fn get_entries_by_type(&self, entry_type: &str, exception_state: &ExceptionState) -> Result<Vec<PerformanceEntry>, String>;
  fn get_entries_by_name(&self, name: &str, type_: &str, exception_state: &ExceptionState) -> Result<Vec<PerformanceEntry>, String>;
  fn mark(&self, name: &str, options: &PerformanceMarkOptions, exception_state: &ExceptionState) -> Result<(), String>;
  fn measure(&self, name: &str, start_mark: NativeValue, end_mark: &str, exception_state: &ExceptionState) -> Result<(), String>;
  fn clear_marks(&self, name: &str, exception_state: &ExceptionState) -> Result<(), String>;
  fn clear_measures(&self, name: &str, exception_state: &ExceptionState) -> Result<(), String>;
  fn as_performance(&self) -> &Performance;
}
impl PerformanceMethods for Performance {
  fn time_origin(&self) -> i64 {
    self.time_origin()
  }
  fn now(&self, exception_state: &ExceptionState) -> Result<i64, String> {
    self.now(exception_state)
  }
  fn webf_navigation_summary(&self, exception_state: &ExceptionState) -> Result<String, String> {
    self.webf_navigation_summary(exception_state)
  }
  fn to_json(&self, exception_state: &ExceptionState) -> Result<NativeValue, String> {
    self.to_json(exception_state)
  }
  fn get_entries(&self, exception_state: &ExceptionState) -> Result<Vec<PerformanceEntry>, String> {
    self.get_entries(exception_state)
  }
  fn get_entries_by_type(&self, entry_type: &str, exception_state: &ExceptionState) -> Result<Vec<PerformanceEntry>, String> {
    self.get_entries_by_type(entry_type, exception_state)
  }
  fn get_entries_by_name(&self, name: &str, type_: &str, exception_state: &ExceptionState) -> Result<Vec<PerformanceEntry>, String> {
    self.get_entries_by_name(name, type_, exception_state)
  }
  fn mark(&self, name: &str, options: &PerformanceMarkOptions, exception_state: &ExceptionState) -> Result<(), String> {
    self.mark(name, options, exception_state)
  }
  fn measure(&self, name: &str, start_mark: NativeValue, end_mark: &str, exception_state: &ExceptionState) -> Result<(), String> {
    self.measure(name, start_mark, end_mark, exception_state)
  }
  fn clear_marks(&self, name: &str, exception_state: &ExceptionState) -> Result<(), String> {
    self.clear_marks(name, exception_state)
  }
  fn clear_measures(&self, name: &str, exception_state: &ExceptionState) -> Result<(), String> {
    self.clear_measures(name, exception_state)
  }
  fn as_performance(&self) -> &Performance {
    self
  }
}

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `webf module-codegen`

import 'package:webf/module.dart';

class OpenDatabaseOptions {
  final String path;
  final num? version;
  final dynamic onCreate;
  final dynamic onUpgrade;
  final bool? readOnly;
  final bool? inMemory;

  const OpenDatabaseOptions({required this.path, this.version, this.onCreate, this.onUpgrade, this.readOnly, this.inMemory});

  factory OpenDatabaseOptions.fromMap(Map<String, dynamic> map) {
    return OpenDatabaseOptions(
      path: map['path']?.toString() ?? '',
      version: map['version'] is num ? map['version'] as num : null,
      onCreate: map['onCreate'],
      onUpgrade: map['onUpgrade'],
      readOnly: map['readOnly'] is bool ? map['readOnly'] as bool : null,
      inMemory: map['inMemory'] is bool ? map['inMemory'] as bool : null,
    );
  }

  Map<String, dynamic> toMap() {
    final map = <String, dynamic>{};
    map['path'] = path;
    if (version != null) { map['version'] = version; }
    if (onCreate != null) { map['onCreate'] = onCreate; }
    if (onUpgrade != null) { map['onUpgrade'] = onUpgrade; }
    if (readOnly != null) { map['readOnly'] = readOnly; }
    if (inMemory != null) { map['inMemory'] = inMemory; }
    return map;
  }

  Map<String, dynamic> toJson() => toMap();
}

class OpenDatabaseResult {
  final String success;
  final String? databaseId;
  final String? path;
  final num? version;
  final String? error;

  const OpenDatabaseResult({required this.success, this.databaseId, this.path, this.version, this.error});

  factory OpenDatabaseResult.fromMap(Map<String, dynamic> map) {
    return OpenDatabaseResult(
      success: map['success']?.toString() ?? '',
      databaseId: map['databaseId']?.toString(),
      path: map['path']?.toString(),
      version: map['version'] is num ? map['version'] as num : null,
      error: map['error']?.toString(),
    );
  }

  Map<String, dynamic> toMap() {
    final map = <String, dynamic>{};
    map['success'] = success;
    if (databaseId != null) { map['databaseId'] = databaseId; }
    if (path != null) { map['path'] = path; }
    if (version != null) { map['version'] = version; }
    if (error != null) { map['error'] = error; }
    return map;
  }

  Map<String, dynamic> toJson() => toMap();
}

class CloseDatabaseResult {
  final String success;
  final String? error;

  const CloseDatabaseResult({required this.success, this.error});

  factory CloseDatabaseResult.fromMap(Map<String, dynamic> map) {
    return CloseDatabaseResult(
      success: map['success']?.toString() ?? '',
      error: map['error']?.toString(),
    );
  }

  Map<String, dynamic> toMap() {
    final map = <String, dynamic>{};
    map['success'] = success;
    if (error != null) { map['error'] = error; }
    return map;
  }

  Map<String, dynamic> toJson() => toMap();
}

class QueryOptions {
  final String databaseId;
  final String table;
  final dynamic columns;
  final String? where;
  final dynamic whereArgs;
  final String? orderBy;
  final num? limit;
  final num? offset;
  final String? groupBy;
  final String? having;
  final bool? distinct;

  const QueryOptions({required this.databaseId, required this.table, this.columns, this.where, this.whereArgs, this.orderBy, this.limit, this.offset, this.groupBy, this.having, this.distinct});

  factory QueryOptions.fromMap(Map<String, dynamic> map) {
    return QueryOptions(
      databaseId: map['databaseId']?.toString() ?? '',
      table: map['table']?.toString() ?? '',
      columns: map['columns'],
      where: map['where']?.toString(),
      whereArgs: map['whereArgs'],
      orderBy: map['orderBy']?.toString(),
      limit: map['limit'] is num ? map['limit'] as num : null,
      offset: map['offset'] is num ? map['offset'] as num : null,
      groupBy: map['groupBy']?.toString(),
      having: map['having']?.toString(),
      distinct: map['distinct'] is bool ? map['distinct'] as bool : null,
    );
  }

  Map<String, dynamic> toMap() {
    final map = <String, dynamic>{};
    map['databaseId'] = databaseId;
    map['table'] = table;
    if (columns != null) { map['columns'] = columns; }
    if (where != null) { map['where'] = where; }
    if (whereArgs != null) { map['whereArgs'] = whereArgs; }
    if (orderBy != null) { map['orderBy'] = orderBy; }
    if (limit != null) { map['limit'] = limit; }
    if (offset != null) { map['offset'] = offset; }
    if (groupBy != null) { map['groupBy'] = groupBy; }
    if (having != null) { map['having'] = having; }
    if (distinct != null) { map['distinct'] = distinct; }
    return map;
  }

  Map<String, dynamic> toJson() => toMap();
}

class QueryResult {
  final String success;
  final String? rows;
  final num? count;
  final String? error;

  const QueryResult({required this.success, this.rows, this.count, this.error});

  factory QueryResult.fromMap(Map<String, dynamic> map) {
    return QueryResult(
      success: map['success']?.toString() ?? '',
      rows: map['rows']?.toString(),
      count: map['count'] is num ? map['count'] as num : null,
      error: map['error']?.toString(),
    );
  }

  Map<String, dynamic> toMap() {
    final map = <String, dynamic>{};
    map['success'] = success;
    if (rows != null) { map['rows'] = rows; }
    if (count != null) { map['count'] = count; }
    if (error != null) { map['error'] = error; }
    return map;
  }

  Map<String, dynamic> toJson() => toMap();
}

class InsertOptions {
  final String databaseId;
  final String table;
  final String values;
  final dynamic conflictAlgorithm;

  const InsertOptions({required this.databaseId, required this.table, required this.values, this.conflictAlgorithm});

  factory InsertOptions.fromMap(Map<String, dynamic> map) {
    return InsertOptions(
      databaseId: map['databaseId']?.toString() ?? '',
      table: map['table']?.toString() ?? '',
      values: map['values']?.toString() ?? '',
      conflictAlgorithm: map['conflictAlgorithm'],
    );
  }

  Map<String, dynamic> toMap() {
    final map = <String, dynamic>{};
    map['databaseId'] = databaseId;
    map['table'] = table;
    map['values'] = values;
    if (conflictAlgorithm != null) { map['conflictAlgorithm'] = conflictAlgorithm; }
    return map;
  }

  Map<String, dynamic> toJson() => toMap();
}

class InsertResult {
  final String success;
  final num? lastInsertRowId;
  final String? error;

  const InsertResult({required this.success, this.lastInsertRowId, this.error});

  factory InsertResult.fromMap(Map<String, dynamic> map) {
    return InsertResult(
      success: map['success']?.toString() ?? '',
      lastInsertRowId: map['lastInsertRowId'] is num ? map['lastInsertRowId'] as num : null,
      error: map['error']?.toString(),
    );
  }

  Map<String, dynamic> toMap() {
    final map = <String, dynamic>{};
    map['success'] = success;
    if (lastInsertRowId != null) { map['lastInsertRowId'] = lastInsertRowId; }
    if (error != null) { map['error'] = error; }
    return map;
  }

  Map<String, dynamic> toJson() => toMap();
}

class UpdateOptions {
  final String databaseId;
  final String table;
  final String values;
  final String? where;
  final dynamic whereArgs;
  final dynamic conflictAlgorithm;

  const UpdateOptions({required this.databaseId, required this.table, required this.values, this.where, this.whereArgs, this.conflictAlgorithm});

  factory UpdateOptions.fromMap(Map<String, dynamic> map) {
    return UpdateOptions(
      databaseId: map['databaseId']?.toString() ?? '',
      table: map['table']?.toString() ?? '',
      values: map['values']?.toString() ?? '',
      where: map['where']?.toString(),
      whereArgs: map['whereArgs'],
      conflictAlgorithm: map['conflictAlgorithm'],
    );
  }

  Map<String, dynamic> toMap() {
    final map = <String, dynamic>{};
    map['databaseId'] = databaseId;
    map['table'] = table;
    map['values'] = values;
    if (where != null) { map['where'] = where; }
    if (whereArgs != null) { map['whereArgs'] = whereArgs; }
    if (conflictAlgorithm != null) { map['conflictAlgorithm'] = conflictAlgorithm; }
    return map;
  }

  Map<String, dynamic> toJson() => toMap();
}

class UpdateResult {
  final String success;
  final num? rowsAffected;
  final String? error;

  const UpdateResult({required this.success, this.rowsAffected, this.error});

  factory UpdateResult.fromMap(Map<String, dynamic> map) {
    return UpdateResult(
      success: map['success']?.toString() ?? '',
      rowsAffected: map['rowsAffected'] is num ? map['rowsAffected'] as num : null,
      error: map['error']?.toString(),
    );
  }

  Map<String, dynamic> toMap() {
    final map = <String, dynamic>{};
    map['success'] = success;
    if (rowsAffected != null) { map['rowsAffected'] = rowsAffected; }
    if (error != null) { map['error'] = error; }
    return map;
  }

  Map<String, dynamic> toJson() => toMap();
}

class DeleteOptions {
  final String databaseId;
  final String table;
  final String? where;
  final dynamic whereArgs;

  const DeleteOptions({required this.databaseId, required this.table, this.where, this.whereArgs});

  factory DeleteOptions.fromMap(Map<String, dynamic> map) {
    return DeleteOptions(
      databaseId: map['databaseId']?.toString() ?? '',
      table: map['table']?.toString() ?? '',
      where: map['where']?.toString(),
      whereArgs: map['whereArgs'],
    );
  }

  Map<String, dynamic> toMap() {
    final map = <String, dynamic>{};
    map['databaseId'] = databaseId;
    map['table'] = table;
    if (where != null) { map['where'] = where; }
    if (whereArgs != null) { map['whereArgs'] = whereArgs; }
    return map;
  }

  Map<String, dynamic> toJson() => toMap();
}

class DeleteResult {
  final String success;
  final num? rowsAffected;
  final String? error;

  const DeleteResult({required this.success, this.rowsAffected, this.error});

  factory DeleteResult.fromMap(Map<String, dynamic> map) {
    return DeleteResult(
      success: map['success']?.toString() ?? '',
      rowsAffected: map['rowsAffected'] is num ? map['rowsAffected'] as num : null,
      error: map['error']?.toString(),
    );
  }

  Map<String, dynamic> toMap() {
    final map = <String, dynamic>{};
    map['success'] = success;
    if (rowsAffected != null) { map['rowsAffected'] = rowsAffected; }
    if (error != null) { map['error'] = error; }
    return map;
  }

  Map<String, dynamic> toJson() => toMap();
}

class RawSqlOptions {
  final String databaseId;
  final String sql;
  final dynamic arguments;

  const RawSqlOptions({required this.databaseId, required this.sql, this.arguments});

  factory RawSqlOptions.fromMap(Map<String, dynamic> map) {
    return RawSqlOptions(
      databaseId: map['databaseId']?.toString() ?? '',
      sql: map['sql']?.toString() ?? '',
      arguments: map['arguments'],
    );
  }

  Map<String, dynamic> toMap() {
    final map = <String, dynamic>{};
    map['databaseId'] = databaseId;
    map['sql'] = sql;
    if (arguments != null) { map['arguments'] = arguments; }
    return map;
  }

  Map<String, dynamic> toJson() => toMap();
}

class RawQueryResult {
  final String success;
  final String? rows;
  final num? count;
  final String? error;

  const RawQueryResult({required this.success, this.rows, this.count, this.error});

  factory RawQueryResult.fromMap(Map<String, dynamic> map) {
    return RawQueryResult(
      success: map['success']?.toString() ?? '',
      rows: map['rows']?.toString(),
      count: map['count'] is num ? map['count'] as num : null,
      error: map['error']?.toString(),
    );
  }

  Map<String, dynamic> toMap() {
    final map = <String, dynamic>{};
    map['success'] = success;
    if (rows != null) { map['rows'] = rows; }
    if (count != null) { map['count'] = count; }
    if (error != null) { map['error'] = error; }
    return map;
  }

  Map<String, dynamic> toJson() => toMap();
}

class RawInsertResult {
  final String success;
  final num? lastInsertRowId;
  final String? error;

  const RawInsertResult({required this.success, this.lastInsertRowId, this.error});

  factory RawInsertResult.fromMap(Map<String, dynamic> map) {
    return RawInsertResult(
      success: map['success']?.toString() ?? '',
      lastInsertRowId: map['lastInsertRowId'] is num ? map['lastInsertRowId'] as num : null,
      error: map['error']?.toString(),
    );
  }

  Map<String, dynamic> toMap() {
    final map = <String, dynamic>{};
    map['success'] = success;
    if (lastInsertRowId != null) { map['lastInsertRowId'] = lastInsertRowId; }
    if (error != null) { map['error'] = error; }
    return map;
  }

  Map<String, dynamic> toJson() => toMap();
}

class RawUpdateResult {
  final String success;
  final num? rowsAffected;
  final String? error;

  const RawUpdateResult({required this.success, this.rowsAffected, this.error});

  factory RawUpdateResult.fromMap(Map<String, dynamic> map) {
    return RawUpdateResult(
      success: map['success']?.toString() ?? '',
      rowsAffected: map['rowsAffected'] is num ? map['rowsAffected'] as num : null,
      error: map['error']?.toString(),
    );
  }

  Map<String, dynamic> toMap() {
    final map = <String, dynamic>{};
    map['success'] = success;
    if (rowsAffected != null) { map['rowsAffected'] = rowsAffected; }
    if (error != null) { map['error'] = error; }
    return map;
  }

  Map<String, dynamic> toJson() => toMap();
}

class ExecuteResult {
  final String success;
  final String? error;

  const ExecuteResult({required this.success, this.error});

  factory ExecuteResult.fromMap(Map<String, dynamic> map) {
    return ExecuteResult(
      success: map['success']?.toString() ?? '',
      error: map['error']?.toString(),
    );
  }

  Map<String, dynamic> toMap() {
    final map = <String, dynamic>{};
    map['success'] = success;
    if (error != null) { map['error'] = error; }
    return map;
  }

  Map<String, dynamic> toJson() => toMap();
}

class BatchOptions {
  final String databaseId;
  final String operations;
  final bool? continueOnError;
  final bool? noResult;

  const BatchOptions({required this.databaseId, required this.operations, this.continueOnError, this.noResult});

  factory BatchOptions.fromMap(Map<String, dynamic> map) {
    return BatchOptions(
      databaseId: map['databaseId']?.toString() ?? '',
      operations: map['operations']?.toString() ?? '',
      continueOnError: map['continueOnError'] is bool ? map['continueOnError'] as bool : null,
      noResult: map['noResult'] is bool ? map['noResult'] as bool : null,
    );
  }

  Map<String, dynamic> toMap() {
    final map = <String, dynamic>{};
    map['databaseId'] = databaseId;
    map['operations'] = operations;
    if (continueOnError != null) { map['continueOnError'] = continueOnError; }
    if (noResult != null) { map['noResult'] = noResult; }
    return map;
  }

  Map<String, dynamic> toJson() => toMap();
}

class BatchResult {
  final String success;
  final String? results;
  final String? error;

  const BatchResult({required this.success, this.results, this.error});

  factory BatchResult.fromMap(Map<String, dynamic> map) {
    return BatchResult(
      success: map['success']?.toString() ?? '',
      results: map['results']?.toString(),
      error: map['error']?.toString(),
    );
  }

  Map<String, dynamic> toMap() {
    final map = <String, dynamic>{};
    map['success'] = success;
    if (results != null) { map['results'] = results; }
    if (error != null) { map['error'] = error; }
    return map;
  }

  Map<String, dynamic> toJson() => toMap();
}

class TransactionOptions {
  final String databaseId;
  final String operations;

  const TransactionOptions({required this.databaseId, required this.operations});

  factory TransactionOptions.fromMap(Map<String, dynamic> map) {
    return TransactionOptions(
      databaseId: map['databaseId']?.toString() ?? '',
      operations: map['operations']?.toString() ?? '',
    );
  }

  Map<String, dynamic> toMap() {
    final map = <String, dynamic>{};
    map['databaseId'] = databaseId;
    map['operations'] = operations;
    return map;
  }

  Map<String, dynamic> toJson() => toMap();
}

class TransactionResult {
  final String success;
  final String? results;
  final String? error;

  const TransactionResult({required this.success, this.results, this.error});

  factory TransactionResult.fromMap(Map<String, dynamic> map) {
    return TransactionResult(
      success: map['success']?.toString() ?? '',
      results: map['results']?.toString(),
      error: map['error']?.toString(),
    );
  }

  Map<String, dynamic> toMap() {
    final map = <String, dynamic>{};
    map['success'] = success;
    if (results != null) { map['results'] = results; }
    if (error != null) { map['error'] = error; }
    return map;
  }

  Map<String, dynamic> toJson() => toMap();
}

class DatabasesPathResult {
  final String success;
  final String? path;
  final String? error;

  const DatabasesPathResult({required this.success, this.path, this.error});

  factory DatabasesPathResult.fromMap(Map<String, dynamic> map) {
    return DatabasesPathResult(
      success: map['success']?.toString() ?? '',
      path: map['path']?.toString(),
      error: map['error']?.toString(),
    );
  }

  Map<String, dynamic> toMap() {
    final map = <String, dynamic>{};
    map['success'] = success;
    if (path != null) { map['path'] = path; }
    if (error != null) { map['error'] = error; }
    return map;
  }

  Map<String, dynamic> toJson() => toMap();
}

class DeleteDatabaseResult {
  final String success;
  final String? error;

  const DeleteDatabaseResult({required this.success, this.error});

  factory DeleteDatabaseResult.fromMap(Map<String, dynamic> map) {
    return DeleteDatabaseResult(
      success: map['success']?.toString() ?? '',
      error: map['error']?.toString(),
    );
  }

  Map<String, dynamic> toMap() {
    final map = <String, dynamic>{};
    map['success'] = success;
    if (error != null) { map['error'] = error; }
    return map;
  }

  Map<String, dynamic> toJson() => toMap();
}

class DatabaseExistsResult {
  final String success;
  final String? exists;
  final String? error;

  const DatabaseExistsResult({required this.success, this.exists, this.error});

  factory DatabaseExistsResult.fromMap(Map<String, dynamic> map) {
    return DatabaseExistsResult(
      success: map['success']?.toString() ?? '',
      exists: map['exists']?.toString(),
      error: map['error']?.toString(),
    );
  }

  Map<String, dynamic> toMap() {
    final map = <String, dynamic>{};
    map['success'] = success;
    if (exists != null) { map['exists'] = exists; }
    if (error != null) { map['error'] = error; }
    return map;
  }

  Map<String, dynamic> toJson() => toMap();
}

abstract class SQFliteModuleBindings extends WebFBaseModule {
  SQFliteModuleBindings(super.moduleManager);

  @override
  String get name => 'SQFlite';

  Future<DatabasesPathResult> getDatabasesPath();
  Future<OpenDatabaseResult> openDatabase(OpenDatabaseOptions? options);
  Future<CloseDatabaseResult> closeDatabase(dynamic databaseId);
  Future<DeleteDatabaseResult> deleteDatabase(dynamic path);
  Future<DatabaseExistsResult> databaseExists(dynamic path);
  Future<QueryResult> query(QueryOptions? options);
  Future<InsertResult> insert(InsertOptions? options);
  Future<UpdateResult> update(UpdateOptions? options);
  Future<DeleteResult> delete(DeleteOptions? options);
  Future<RawQueryResult> rawQuery(RawSqlOptions? options);
  Future<RawInsertResult> rawInsert(RawSqlOptions? options);
  Future<RawUpdateResult> rawUpdate(RawSqlOptions? options);
  Future<RawUpdateResult> rawDelete(RawSqlOptions? options);
  Future<ExecuteResult> execute(RawSqlOptions? options);
  Future<BatchResult> batch(BatchOptions? options);
  Future<TransactionResult> transaction(TransactionOptions? options);

  @override
  Future<dynamic> invoke(String method, List<dynamic> params) async {
    switch (method) {
      case 'getDatabasesPath': {
        final result = await getDatabasesPath();
        return result.toMap();
      }
      case 'openDatabase': {
        final _raw0 = params.length > 0 ? params[0] : null;
        final options = _raw0 is Map ? OpenDatabaseOptions.fromMap(Map<String, dynamic>.from(_raw0 as Map)) : (_raw0 as OpenDatabaseOptions?);
        final result = await openDatabase(options);
        return result.toMap();
      }
      case 'closeDatabase': {
        final result = await closeDatabase(params.length > 0 ? params[0] : null);
        return result.toMap();
      }
      case 'deleteDatabase': {
        final result = await deleteDatabase(params.length > 0 ? params[0] : null);
        return result.toMap();
      }
      case 'databaseExists': {
        final result = await databaseExists(params.length > 0 ? params[0] : null);
        return result.toMap();
      }
      case 'query': {
        final _raw0 = params.length > 0 ? params[0] : null;
        final options = _raw0 is Map ? QueryOptions.fromMap(Map<String, dynamic>.from(_raw0 as Map)) : (_raw0 as QueryOptions?);
        final result = await query(options);
        return result.toMap();
      }
      case 'insert': {
        final _raw0 = params.length > 0 ? params[0] : null;
        final options = _raw0 is Map ? InsertOptions.fromMap(Map<String, dynamic>.from(_raw0 as Map)) : (_raw0 as InsertOptions?);
        final result = await insert(options);
        return result.toMap();
      }
      case 'update': {
        final _raw0 = params.length > 0 ? params[0] : null;
        final options = _raw0 is Map ? UpdateOptions.fromMap(Map<String, dynamic>.from(_raw0 as Map)) : (_raw0 as UpdateOptions?);
        final result = await update(options);
        return result.toMap();
      }
      case 'delete': {
        final _raw0 = params.length > 0 ? params[0] : null;
        final options = _raw0 is Map ? DeleteOptions.fromMap(Map<String, dynamic>.from(_raw0 as Map)) : (_raw0 as DeleteOptions?);
        final result = await delete(options);
        return result.toMap();
      }
      case 'rawQuery': {
        final _raw0 = params.length > 0 ? params[0] : null;
        final options = _raw0 is Map ? RawSqlOptions.fromMap(Map<String, dynamic>.from(_raw0 as Map)) : (_raw0 as RawSqlOptions?);
        final result = await rawQuery(options);
        return result.toMap();
      }
      case 'rawInsert': {
        final _raw0 = params.length > 0 ? params[0] : null;
        final options = _raw0 is Map ? RawSqlOptions.fromMap(Map<String, dynamic>.from(_raw0 as Map)) : (_raw0 as RawSqlOptions?);
        final result = await rawInsert(options);
        return result.toMap();
      }
      case 'rawUpdate': {
        final _raw0 = params.length > 0 ? params[0] : null;
        final options = _raw0 is Map ? RawSqlOptions.fromMap(Map<String, dynamic>.from(_raw0 as Map)) : (_raw0 as RawSqlOptions?);
        final result = await rawUpdate(options);
        return result.toMap();
      }
      case 'rawDelete': {
        final _raw0 = params.length > 0 ? params[0] : null;
        final options = _raw0 is Map ? RawSqlOptions.fromMap(Map<String, dynamic>.from(_raw0 as Map)) : (_raw0 as RawSqlOptions?);
        final result = await rawDelete(options);
        return result.toMap();
      }
      case 'execute': {
        final _raw0 = params.length > 0 ? params[0] : null;
        final options = _raw0 is Map ? RawSqlOptions.fromMap(Map<String, dynamic>.from(_raw0 as Map)) : (_raw0 as RawSqlOptions?);
        final result = await execute(options);
        return result.toMap();
      }
      case 'batch': {
        final _raw0 = params.length > 0 ? params[0] : null;
        final options = _raw0 is Map ? BatchOptions.fromMap(Map<String, dynamic>.from(_raw0 as Map)) : (_raw0 as BatchOptions?);
        final result = await batch(options);
        return result.toMap();
      }
      case 'transaction': {
        final _raw0 = params.length > 0 ? params[0] : null;
        final options = _raw0 is Map ? TransactionOptions.fromMap(Map<String, dynamic>.from(_raw0 as Map)) : (_raw0 as TransactionOptions?);
        final result = await transaction(options);
        return result.toMap();
      }
      default:
        throw Exception('Unknown method for module ${name}: $method');
    }
  }
}

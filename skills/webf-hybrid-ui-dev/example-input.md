# Complete Example: Text Input Component

This is a complete, working example of a hybrid UI component that wraps Flutter's TextFormField.

## File Structure

```
my_component_lib/
└── lib/
    └── src/
        ├── text_input.dart        # Dart implementation
        ├── text_input.d.ts        # TypeScript definitions
        └── text_input_bindings_generated.dart  # Generated by CLI
```

## Step 1: TypeScript Definitions

**File: `lib/src/text_input.d.ts`**

```typescript
/**
 * A text input component with validation and multiple keyboard types.
 */

type int = number;

/**
 * Properties for <my-text-input>.
 */
interface MyTextInputProperties {
  /**
   * Current text value.
   */
  value?: string;

  /**
   * Placeholder text shown when empty.
   */
  placeholder?: string;

  /**
   * Maximum character length.
   */
  maxLength?: int;

  /**
   * Input type for keyboard.
   * Supported: 'text', 'email', 'number', 'phone', 'url'
   * @default 'text'
   */
  type?: string;

  /**
   * Whether input is disabled.
   * @default false
   */
  disabled?: boolean;

  /**
   * Whether input is read-only.
   * @default false
   */
  readonly?: boolean;

  /**
   * Auto-focus on mount.
   * @default false
   */
  autofocus?: boolean;

  /**
   * Obscure text (for passwords).
   * @default false
   */
  obscureText?: boolean;

  /**
   * Error message to display.
   */
  errorText?: string;

  /**
   * Helper text to display below input.
   */
  helperText?: string;

  // Methods

  /**
   * Programmatically focus the input.
   */
  focus(): void;

  /**
   * Programmatically blur the input.
   */
  blur(): void;

  /**
   * Clear the current value.
   */
  clear(): void;

  /**
   * Get the current value.
   */
  getValue(): string;

  /**
   * Set a new value.
   */
  setValue(value: string): void;
}

/**
 * Events for <my-text-input>.
 */
interface MyTextInputEvents {
  /**
   * Fired on every text change.
   * detail.value = current text
   */
  input: CustomEvent<string>;

  /**
   * Fired when Enter is pressed.
   * detail.value = current text
   */
  submit: CustomEvent<string>;

  /**
   * Fired when input gains focus.
   */
  focus: Event;

  /**
   * Fired when input loses focus.
   */
  blur: Event;

  /**
   * Fired when validation fails.
   * detail.message = error message
   */
  error: CustomEvent<string>;
}
```

## Step 2: Dart Implementation

**File: `lib/src/text_input.dart`**

```dart
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:webf/webf.dart';
import 'text_input_bindings_generated.dart';

class MyTextInput extends MyTextInputBindings {
  MyTextInput(super.context);

  // Internal state
  String _value = '';
  String _placeholder = '';
  int? _maxLength;
  String _type = 'text';
  bool _disabled = false;
  bool _readonly = false;
  bool _autofocus = false;
  bool _obscureText = false;
  String? _errorText;
  String? _helperText;

  // Property getters/setters
  @override
  String get value => _value;

  @override
  set value(String val) {
    _value = val;
    setState(() {});
  }

  @override
  String get placeholder => _placeholder;

  @override
  set placeholder(String val) {
    _placeholder = val;
    setState(() {});
  }

  @override
  String? get maxLength => _maxLength?.toString();

  @override
  set maxLength(String? val) {
    _maxLength = val != null ? int.tryParse(val) : null;
    setState(() {});
  }

  @override
  String get type => _type;

  @override
  set type(String val) {
    _type = val;
    setState(() {});
  }

  @override
  bool get disabled => _disabled;

  @override
  set disabled(bool val) {
    _disabled = val;
    setState(() {});
  }

  @override
  bool get readonly => _readonly;

  @override
  set readonly(bool val) {
    _readonly = val;
    setState(() {});
  }

  @override
  bool get autofocus => _autofocus;

  @override
  set autofocus(bool val) {
    _autofocus = val;
    setState(() {});
  }

  @override
  bool get obscureText => _obscureText;

  @override
  set obscureText(bool val) {
    _obscureText = val;
    setState(() {});
  }

  @override
  String? get errorText => _errorText;

  @override
  set errorText(String? val) {
    _errorText = val;
    setState(() {});
  }

  @override
  String? get helperText => _helperText;

  @override
  set helperText(String? val) {
    _helperText = val;
    setState(() {});
  }

  // Methods
  @override
  void focus() {
    final state = this.state as MyTextInputState?;
    state?._focusNode.requestFocus();
  }

  @override
  void blur() {
    final state = this.state as MyTextInputState?;
    state?._focusNode.unfocus();
  }

  @override
  void clear() {
    value = '';
    dispatchEvent(CustomEvent('input', detail: {'value': ''}));
  }

  @override
  String getValue() {
    return _value;
  }

  @override
  void setValue(String val) {
    value = val;
  }

  @override
  WebFWidgetElementState createState() {
    return MyTextInputState(this);
  }
}

class MyTextInputState extends WebFWidgetElementState {
  MyTextInputState(super.widgetElement);

  final FocusNode _focusNode = FocusNode();
  late TextEditingController _controller;

  @override
  MyTextInput get widgetElement => super.widgetElement as MyTextInput;

  @override
  void initState() {
    super.initState();
    _controller = TextEditingController(text: widgetElement.value);

    // Listen for focus changes
    _focusNode.addListener(_handleFocusChange);
  }

  @override
  void didUpdateWidget() {
    super.didUpdateWidget();
    // Update controller if value changed externally
    if (_controller.text != widgetElement.value) {
      _controller.text = widgetElement.value;
    }
  }

  @override
  void dispose() {
    _focusNode.removeListener(_handleFocusChange);
    _focusNode.dispose();
    _controller.dispose();
    super.dispose();
  }

  void _handleFocusChange() {
    if (_focusNode.hasFocus) {
      widgetElement.dispatchEvent(Event('focus'));
    } else {
      widgetElement.dispatchEvent(Event('blur'));
    }
  }

  TextInputType _getKeyboardType() {
    switch (widgetElement.type) {
      case 'email':
        return TextInputType.emailAddress;
      case 'number':
        return TextInputType.number;
      case 'phone':
        return TextInputType.phone;
      case 'url':
        return TextInputType.url;
      default:
        return TextInputType.text;
    }
  }

  @override
  Widget build(BuildContext context) {
    return TextFormField(
      controller: _controller,
      focusNode: _focusNode,
      enabled: !widgetElement.disabled,
      readOnly: widgetElement.readonly,
      autofocus: widgetElement.autofocus,
      obscureText: widgetElement.obscureText,
      keyboardType: _getKeyboardType(),
      maxLength: widgetElement._maxLength,
      decoration: InputDecoration(
        hintText: widgetElement.placeholder,
        errorText: widgetElement.errorText,
        helperText: widgetElement.helperText,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(8),
        ),
        contentPadding: EdgeInsets.symmetric(horizontal: 12, vertical: 10),
      ),
      onChanged: (value) {
        widgetElement._value = value;
        widgetElement.dispatchEvent(CustomEvent(
          'input',
          detail: {'value': value},
        ));
      },
      onFieldSubmitted: (value) {
        widgetElement.dispatchEvent(CustomEvent(
          'submit',
          detail: {'value': value},
        ));
      },
      validator: (value) {
        // Custom validation can be added here
        if (widgetElement._maxLength != null &&
            value != null &&
            value.length > widgetElement._maxLength!) {
          final error = 'Maximum ${widgetElement._maxLength} characters';
          widgetElement.dispatchEvent(CustomEvent(
            'error',
            detail: {'message': error},
          ));
          return error;
        }
        return null;
      },
    );
  }
}
```

## Step 3: Generate React/Vue Components

```bash
# Generate React components
webf codegen my-ui-lib-react \
  --flutter-package-src=./my_component_lib \
  --framework=react \
  --package-name=@mycompany/my-ui-lib

# Generate Vue components
webf codegen my-ui-lib-vue \
  --flutter-package-src=./my_component_lib \
  --framework=vue \
  --package-name=@mycompany/my-ui-lib-vue
```

## Step 4: Usage Examples

### React Usage

```tsx
import { MyTextInput } from '@mycompany/my-ui-lib';
import { useState } from 'react';

function LoginForm() {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');

  const handleSubmit = () => {
    if (!username || !password) {
      setError('Please fill in all fields');
      return;
    }
    // Perform login
    console.log('Login:', { username, password });
  };

  return (
    <div>
      <MyTextInput
        placeholder="Username"
        value={username}
        onInput={(e) => setUsername(e.detail.value)}
        errorText={error}
      />

      <MyTextInput
        placeholder="Password"
        type="password"
        obscureText
        value={password}
        onInput={(e) => setPassword(e.detail.value)}
        onSubmit={handleSubmit}
      />

      <button onClick={handleSubmit}>Login</button>
    </div>
  );
}
```

### Vue Usage

```vue
<template>
  <div class="login-form">
    <MyTextInput
      placeholder="Username"
      :value="username"
      @input="handleUsernameInput"
      :errorText="error"
    />

    <MyTextInput
      placeholder="Password"
      type="password"
      :obscureText="true"
      :value="password"
      @input="handlePasswordInput"
      @submit="handleSubmit"
    />

    <button @click="handleSubmit">Login</button>
  </div>
</template>

<script setup>
import { ref } from 'vue';
import { MyTextInput } from '@mycompany/my-ui-lib-vue';

const username = ref('');
const password = ref('');
const error = ref('');

const handleUsernameInput = (e) => {
  username.value = e.detail.value;
};

const handlePasswordInput = (e) => {
  password.value = e.detail.value;
};

const handleSubmit = () => {
  if (!username.value || !password.value) {
    error.value = 'Please fill in all fields';
    return;
  }
  // Perform login
  console.log('Login:', {
    username: username.value,
    password: password.value
  });
};
</script>
```

### Vanilla JavaScript Usage

```html
<my-text-input
  id="emailInput"
  placeholder="Enter email"
  type="email"
></my-text-input>

<script>
  const input = document.getElementById('emailInput');

  input.addEventListener('input', (e) => {
    console.log('Value changed:', e.detail.value);
  });

  input.addEventListener('submit', (e) => {
    console.log('Submitted:', e.detail.value);
  });

  // Call methods
  input.focus();
  input.setValue('test@example.com');
</script>
```

## Step 5: Register in Flutter App

**main.dart:**

```dart
import 'package:flutter/material.dart';
import 'package:webf/webf.dart';
import 'package:my_component_lib/my_component_lib.dart';

void main() {
  WebFControllerManager.instance.initialize(WebFControllerManagerConfig(
    maxAliveInstances: 2,
    maxAttachedInstances: 1,
  ));

  // Register custom element
  WebFController.defineCustomElement(
    'my-text-input',
    (context) => MyTextInput(context),
  );

  runApp(MyApp());
}
```

## Key Takeaways

1. ✅ **TypeScript definitions** define the component interface
2. ✅ **Dart implementation** wraps Flutter widget (TextFormField)
3. ✅ **State management** uses `setState()` to trigger rebuilds
4. ✅ **Event dispatching** communicates changes back to JavaScript
5. ✅ **Methods** provide programmatic control from JavaScript
6. ✅ **CLI generation** creates type-safe React/Vue components
7. ✅ **Registration** makes component available in Flutter app

This pattern can be applied to wrap any Flutter widget as a WebF custom element!

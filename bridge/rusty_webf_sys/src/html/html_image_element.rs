// Generated by WebF TSDL, don't edit this file directly.
// Generate command: node scripts/generate_binding_code.js
/*
* Copyright (C) 2022-present The WebF authors. All rights reserved.
*/
use std::ffi::*;
use crate::*;
#[repr(C)]
pub struct HTMLImageElementRustMethods {
  pub version: c_double,
  pub html_element: HTMLElementRustMethods,
  pub alt: extern "C" fn(ptr: *const OpaquePtr) -> AtomicStringRef,
  pub set_alt: extern "C" fn(ptr: *const OpaquePtr, value: *const c_char, exception_state: *const OpaquePtr) -> bool,
  pub src: extern "C" fn(ptr: *const OpaquePtr) -> AtomicStringRef,
  pub set_src: extern "C" fn(ptr: *const OpaquePtr, value: *const c_char, exception_state: *const OpaquePtr) -> bool,
  pub sizes: extern "C" fn(ptr: *const OpaquePtr) -> AtomicStringRef,
  pub set_sizes: extern "C" fn(ptr: *const OpaquePtr, value: *const c_char, exception_state: *const OpaquePtr) -> bool,
  pub width: extern "C" fn(ptr: *const OpaquePtr) -> i64,
  pub set_width: extern "C" fn(ptr: *const OpaquePtr, value: i64, exception_state: *const OpaquePtr) -> bool,
  pub height: extern "C" fn(ptr: *const OpaquePtr) -> i64,
  pub set_height: extern "C" fn(ptr: *const OpaquePtr, value: i64, exception_state: *const OpaquePtr) -> bool,
  pub natural_width: extern "C" fn(ptr: *const OpaquePtr) -> i64,
  pub natural_height: extern "C" fn(ptr: *const OpaquePtr) -> i64,
  pub complete: extern "C" fn(ptr: *const OpaquePtr) -> i32,
  pub current_src: extern "C" fn(ptr: *const OpaquePtr) -> AtomicStringRef,
  pub decoding: extern "C" fn(ptr: *const OpaquePtr) -> AtomicStringRef,
  pub set_decoding: extern "C" fn(ptr: *const OpaquePtr, value: *const c_char, exception_state: *const OpaquePtr) -> bool,
  pub fetch_priority: extern "C" fn(ptr: *const OpaquePtr) -> AtomicStringRef,
  pub set_fetch_priority: extern "C" fn(ptr: *const OpaquePtr, value: *const c_char, exception_state: *const OpaquePtr) -> bool,
  pub loading: extern "C" fn(ptr: *const OpaquePtr) -> AtomicStringRef,
  pub set_loading: extern "C" fn(ptr: *const OpaquePtr, value: *const c_char, exception_state: *const OpaquePtr) -> bool,
}
pub struct HTMLImageElement {
  pub html_element: HTMLElement,
  method_pointer: *const HTMLImageElementRustMethods,
}
impl HTMLImageElement {
  pub fn initialize(ptr: *const OpaquePtr, context: *const ExecutingContext, method_pointer: *const HTMLImageElementRustMethods, status: *const RustValueStatus) -> HTMLImageElement {
    unsafe {
      HTMLImageElement {
        html_element: HTMLElement::initialize(
          ptr,
          context,
          &(method_pointer).as_ref().unwrap().html_element,
          status,
        ),
        method_pointer,
      }
    }
  }
  pub fn ptr(&self) -> *const OpaquePtr {
    self.html_element.ptr()
  }
  pub fn context<'a>(&self) -> &'a ExecutingContext {
    self.html_element.context()
  }
  pub fn alt(&self) -> String {
    let value = unsafe {
      ((*self.method_pointer).alt)(self.ptr())
    };
    value.to_string()
  }
  pub fn set_alt(&self, value: String, exception_state: &ExceptionState) -> Result<(), String> {
    unsafe {
      ((*self.method_pointer).set_alt)(self.ptr(), CString::new(value).unwrap().as_ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(())
  }
  pub fn src(&self) -> String {
    let value = unsafe {
      ((*self.method_pointer).src)(self.ptr())
    };
    value.to_string()
  }
  pub fn set_src(&self, value: String, exception_state: &ExceptionState) -> Result<(), String> {
    unsafe {
      ((*self.method_pointer).set_src)(self.ptr(), CString::new(value).unwrap().as_ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(())
  }
  pub fn sizes(&self) -> String {
    let value = unsafe {
      ((*self.method_pointer).sizes)(self.ptr())
    };
    value.to_string()
  }
  pub fn set_sizes(&self, value: String, exception_state: &ExceptionState) -> Result<(), String> {
    unsafe {
      ((*self.method_pointer).set_sizes)(self.ptr(), CString::new(value).unwrap().as_ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(())
  }
  pub fn width(&self) -> i64 {
    let value = unsafe {
      ((*self.method_pointer).width)(self.ptr())
    };
    value
  }
  pub fn set_width(&self, value: i64, exception_state: &ExceptionState) -> Result<(), String> {
    unsafe {
      ((*self.method_pointer).set_width)(self.ptr(), value, exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(())
  }
  pub fn height(&self) -> i64 {
    let value = unsafe {
      ((*self.method_pointer).height)(self.ptr())
    };
    value
  }
  pub fn set_height(&self, value: i64, exception_state: &ExceptionState) -> Result<(), String> {
    unsafe {
      ((*self.method_pointer).set_height)(self.ptr(), value, exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(())
  }
  pub fn natural_width(&self) -> i64 {
    let value = unsafe {
      ((*self.method_pointer).natural_width)(self.ptr())
    };
    value
  }
  pub fn natural_height(&self) -> i64 {
    let value = unsafe {
      ((*self.method_pointer).natural_height)(self.ptr())
    };
    value
  }
  pub fn complete(&self) -> bool {
    let value = unsafe {
      ((*self.method_pointer).complete)(self.ptr())
    };
    value != 0
  }
  pub fn current_src(&self) -> String {
    let value = unsafe {
      ((*self.method_pointer).current_src)(self.ptr())
    };
    value.to_string()
  }
  pub fn decoding(&self) -> String {
    let value = unsafe {
      ((*self.method_pointer).decoding)(self.ptr())
    };
    value.to_string()
  }
  pub fn set_decoding(&self, value: String, exception_state: &ExceptionState) -> Result<(), String> {
    unsafe {
      ((*self.method_pointer).set_decoding)(self.ptr(), CString::new(value).unwrap().as_ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(())
  }
  pub fn fetch_priority(&self) -> String {
    let value = unsafe {
      ((*self.method_pointer).fetch_priority)(self.ptr())
    };
    value.to_string()
  }
  pub fn set_fetch_priority(&self, value: String, exception_state: &ExceptionState) -> Result<(), String> {
    unsafe {
      ((*self.method_pointer).set_fetch_priority)(self.ptr(), CString::new(value).unwrap().as_ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(())
  }
  pub fn loading(&self) -> String {
    let value = unsafe {
      ((*self.method_pointer).loading)(self.ptr())
    };
    value.to_string()
  }
  pub fn set_loading(&self, value: String, exception_state: &ExceptionState) -> Result<(), String> {
    unsafe {
      ((*self.method_pointer).set_loading)(self.ptr(), CString::new(value).unwrap().as_ptr(), exception_state.ptr)
    };
    if exception_state.has_exception() {
      return Err(exception_state.stringify(self.context()));
    }
    Ok(())
  }
}
pub trait HTMLImageElementMethods: HTMLElementMethods {
  fn alt(&self) -> String;
  fn set_alt(&self, value: String, exception_state: &ExceptionState) -> Result<(), String>;
  fn src(&self) -> String;
  fn set_src(&self, value: String, exception_state: &ExceptionState) -> Result<(), String>;
  fn sizes(&self) -> String;
  fn set_sizes(&self, value: String, exception_state: &ExceptionState) -> Result<(), String>;
  fn width(&self) -> i64;
  fn set_width(&self, value: i64, exception_state: &ExceptionState) -> Result<(), String>;
  fn height(&self) -> i64;
  fn set_height(&self, value: i64, exception_state: &ExceptionState) -> Result<(), String>;
  fn natural_width(&self) -> i64;
  fn natural_height(&self) -> i64;
  fn complete(&self) -> bool;
  fn current_src(&self) -> String;
  fn decoding(&self) -> String;
  fn set_decoding(&self, value: String, exception_state: &ExceptionState) -> Result<(), String>;
  fn fetch_priority(&self) -> String;
  fn set_fetch_priority(&self, value: String, exception_state: &ExceptionState) -> Result<(), String>;
  fn loading(&self) -> String;
  fn set_loading(&self, value: String, exception_state: &ExceptionState) -> Result<(), String>;
  fn as_html_image_element(&self) -> &HTMLImageElement;
}
impl HTMLImageElementMethods for HTMLImageElement {
  fn alt(&self) -> String {
    self.alt()
  }
  fn set_alt(&self, value: String, exception_state: &ExceptionState) -> Result<(), String> {
    self.set_alt(value, exception_state)
  }
  fn src(&self) -> String {
    self.src()
  }
  fn set_src(&self, value: String, exception_state: &ExceptionState) -> Result<(), String> {
    self.set_src(value, exception_state)
  }
  fn sizes(&self) -> String {
    self.sizes()
  }
  fn set_sizes(&self, value: String, exception_state: &ExceptionState) -> Result<(), String> {
    self.set_sizes(value, exception_state)
  }
  fn width(&self) -> i64 {
    self.width()
  }
  fn set_width(&self, value: i64, exception_state: &ExceptionState) -> Result<(), String> {
    self.set_width(value, exception_state)
  }
  fn height(&self) -> i64 {
    self.height()
  }
  fn set_height(&self, value: i64, exception_state: &ExceptionState) -> Result<(), String> {
    self.set_height(value, exception_state)
  }
  fn natural_width(&self) -> i64 {
    self.natural_width()
  }
  fn natural_height(&self) -> i64 {
    self.natural_height()
  }
  fn complete(&self) -> bool {
    self.complete()
  }
  fn current_src(&self) -> String {
    self.current_src()
  }
  fn decoding(&self) -> String {
    self.decoding()
  }
  fn set_decoding(&self, value: String, exception_state: &ExceptionState) -> Result<(), String> {
    self.set_decoding(value, exception_state)
  }
  fn fetch_priority(&self) -> String {
    self.fetch_priority()
  }
  fn set_fetch_priority(&self, value: String, exception_state: &ExceptionState) -> Result<(), String> {
    self.set_fetch_priority(value, exception_state)
  }
  fn loading(&self) -> String {
    self.loading()
  }
  fn set_loading(&self, value: String, exception_state: &ExceptionState) -> Result<(), String> {
    self.set_loading(value, exception_state)
  }
  fn as_html_image_element(&self) -> &HTMLImageElement {
    self
  }
}
impl HTMLElementMethods for HTMLImageElement {
  fn offset_top(&self) -> f64 {
    self.html_element.offset_top()
  }
  fn offset_left(&self) -> f64 {
    self.html_element.offset_left()
  }
  fn offset_width(&self) -> f64 {
    self.html_element.offset_width()
  }
  fn offset_height(&self) -> f64 {
    self.html_element.offset_height()
  }
  fn click(&self, exception_state: &ExceptionState) -> Result<(), String> {
    self.html_element.click(exception_state)
  }
  fn as_html_element(&self) -> &HTMLElement {
    &self.html_element
  }
}
impl ElementMethods for HTMLImageElement {
  fn id(&self) -> String {
    self.html_element.element.id()
  }
  fn set_id(&self, value: String, exception_state: &ExceptionState) -> Result<(), String> {
    self.html_element.element.set_id(value, exception_state)
  }
  fn class_name(&self) -> String {
    self.html_element.element.class_name()
  }
  fn set_class_name(&self, value: String, exception_state: &ExceptionState) -> Result<(), String> {
    self.html_element.element.set_class_name(value, exception_state)
  }
  fn dataset(&self) -> DOMStringMap {
    self.html_element.element.dataset()
  }
  fn name(&self) -> String {
    self.html_element.element.name()
  }
  fn set_name(&self, value: String, exception_state: &ExceptionState) -> Result<(), String> {
    self.html_element.element.set_name(value, exception_state)
  }
  fn attributes(&self) -> ElementAttributes {
    self.html_element.element.attributes()
  }
  fn style(&self) -> CSSStyleDeclaration {
    self.html_element.element.style()
  }
  fn client_height(&self) -> f64 {
    self.html_element.element.client_height()
  }
  fn client_left(&self) -> f64 {
    self.html_element.element.client_left()
  }
  fn client_top(&self) -> f64 {
    self.html_element.element.client_top()
  }
  fn client_width(&self) -> f64 {
    self.html_element.element.client_width()
  }
  fn outer_html(&self) -> String {
    self.html_element.element.outer_html()
  }
  fn inner_html(&self) -> String {
    self.html_element.element.inner_html()
  }
  fn set_inner_html(&self, value: String, exception_state: &ExceptionState) -> Result<(), String> {
    self.html_element.element.set_inner_html(value, exception_state)
  }
  fn owner_document(&self) -> Document {
    self.html_element.element.owner_document()
  }
  fn scroll_left(&self) -> f64 {
    self.html_element.element.scroll_left()
  }
  fn set_scroll_left(&self, value: f64, exception_state: &ExceptionState) -> Result<(), String> {
    self.html_element.element.set_scroll_left(value, exception_state)
  }
  fn scroll_top(&self) -> f64 {
    self.html_element.element.scroll_top()
  }
  fn set_scroll_top(&self, value: f64, exception_state: &ExceptionState) -> Result<(), String> {
    self.html_element.element.set_scroll_top(value, exception_state)
  }
  fn scroll_width(&self) -> f64 {
    self.html_element.element.scroll_width()
  }
  fn scroll_height(&self) -> f64 {
    self.html_element.element.scroll_height()
  }
  fn local_name(&self) -> String {
    self.html_element.element.local_name()
  }
  fn tag_name(&self) -> String {
    self.html_element.element.tag_name()
  }
  fn dir(&self) -> String {
    self.html_element.element.dir()
  }
  fn set_dir(&self, value: String, exception_state: &ExceptionState) -> Result<(), String> {
    self.html_element.element.set_dir(value, exception_state)
  }
  fn set_attribute(&self, qualified_name: &str, value: &str, exception_state: &ExceptionState) -> Result<(), String> {
    self.html_element.element.set_attribute(qualified_name, value, exception_state)
  }
  fn remove_attribute(&self, qualified_name: &str, exception_state: &ExceptionState) -> Result<(), String> {
    self.html_element.element.remove_attribute(qualified_name, exception_state)
  }
  fn has_attribute(&self, qualified_name: &str, exception_state: &ExceptionState) -> Result<bool, String> {
    self.html_element.element.has_attribute(qualified_name, exception_state)
  }
  fn get_bounding_client_rect(&self, exception_state: &ExceptionState) -> Result<BoundingClientRect, String> {
    self.html_element.element.get_bounding_client_rect(exception_state)
  }
  fn get_client_rects(&self, exception_state: &ExceptionState) -> Result<Vec<BoundingClientRect>, String> {
    self.html_element.element.get_client_rects(exception_state)
  }
  fn get_elements_by_class_name(&self, class_name: &str, exception_state: &ExceptionState) -> Result<Vec<Element>, String> {
    self.html_element.element.get_elements_by_class_name(class_name, exception_state)
  }
  fn get_elements_by_tag_name(&self, tag_name: &str, exception_state: &ExceptionState) -> Result<Vec<Element>, String> {
    self.html_element.element.get_elements_by_tag_name(tag_name, exception_state)
  }
  fn query_selector(&self, selectors: &str, exception_state: &ExceptionState) -> Result<Element, String> {
    self.html_element.element.query_selector(selectors, exception_state)
  }
  fn query_selector_all(&self, selectors: &str, exception_state: &ExceptionState) -> Result<Vec<Element>, String> {
    self.html_element.element.query_selector_all(selectors, exception_state)
  }
  fn matches(&self, selectors: &str, exception_state: &ExceptionState) -> Result<bool, String> {
    self.html_element.element.matches(selectors, exception_state)
  }
  fn closest(&self, selectors: &str, exception_state: &ExceptionState) -> Result<Element, String> {
    self.html_element.element.closest(selectors, exception_state)
  }
  fn scroll(&self, x: f64, y: f64, exception_state: &ExceptionState) -> Result<(), String> {
    self.html_element.element.scroll(x, y, exception_state)
  }
  fn scroll_with_options(&self, options: &ScrollToOptions, exception_state: &ExceptionState) -> Result<(), String> {
    self.html_element.element.scroll_with_options(options, exception_state)
  }
  fn scroll_by(&self, x: f64, y: f64, exception_state: &ExceptionState) -> Result<(), String> {
    self.html_element.element.scroll_by(x, y, exception_state)
  }
  fn scroll_by_with_options(&self, options: &ScrollToOptions, exception_state: &ExceptionState) -> Result<(), String> {
    self.html_element.element.scroll_by_with_options(options, exception_state)
  }
  fn scroll_to(&self, x: f64, y: f64, exception_state: &ExceptionState) -> Result<(), String> {
    self.html_element.element.scroll_to(x, y, exception_state)
  }
  fn scroll_to_with_options(&self, options: &ScrollToOptions, exception_state: &ExceptionState) -> Result<(), String> {
    self.html_element.element.scroll_to_with_options(options, exception_state)
  }
  fn test_global_to_local(&self, x: f64, y: f64, exception_state: &ExceptionState) -> Result<NativeValue, String> {
    self.html_element.element.test_global_to_local(x, y, exception_state)
  }
  fn as_element(&self) -> &Element {
    &self.html_element.element
  }
}
impl NodeMethods for HTMLImageElement {
  fn element_node(&self) -> f64 {
    self.html_element.element.node.element_node()
  }
  fn attribute_node(&self) -> f64 {
    self.html_element.element.node.attribute_node()
  }
  fn text_node(&self) -> f64 {
    self.html_element.element.node.text_node()
  }
  fn comment_node(&self) -> f64 {
    self.html_element.element.node.comment_node()
  }
  fn document_node(&self) -> f64 {
    self.html_element.element.node.document_node()
  }
  fn document_type_node(&self) -> f64 {
    self.html_element.element.node.document_type_node()
  }
  fn document_fragment_node(&self) -> f64 {
    self.html_element.element.node.document_fragment_node()
  }
  fn node_type(&self) -> f64 {
    self.html_element.element.node.node_type()
  }
  fn node_name(&self) -> String {
    self.html_element.element.node.node_name()
  }
  fn child_nodes(&self) -> NodeList {
    self.html_element.element.node.child_nodes()
  }
  fn first_child(&self) -> Node {
    self.html_element.element.node.first_child()
  }
  fn is_connected(&self) -> bool {
    self.html_element.element.node.is_connected()
  }
  fn last_child(&self) -> Node {
    self.html_element.element.node.last_child()
  }
  fn next_sibling(&self) -> Node {
    self.html_element.element.node.next_sibling()
  }
  fn owner_document(&self) -> Document {
    self.html_element.element.node.owner_document()
  }
  fn parent_element(&self) -> Element {
    self.html_element.element.node.parent_element()
  }
  fn parent_node(&self) -> Node {
    self.html_element.element.node.parent_node()
  }
  fn previous_sibling(&self) -> Node {
    self.html_element.element.node.previous_sibling()
  }
  fn has_child_nodes(&self, exception_state: &ExceptionState) -> Result<bool, String> {
    self.html_element.element.node.has_child_nodes(exception_state)
  }
  fn append_child(&self, new_node: &Node, exception_state: &ExceptionState) -> Result<Node, String> {
    self.html_element.element.node.append_child(new_node, exception_state)
  }
  fn clone_node(&self, deep: bool, exception_state: &ExceptionState) -> Result<Node, String> {
    self.html_element.element.node.clone_node(deep, exception_state)
  }
  fn contains(&self, other: &Node, exception_state: &ExceptionState) -> Result<bool, String> {
    self.html_element.element.node.contains(other, exception_state)
  }
  fn insert_before(&self, new_child: &Node, ref_child: &Node, exception_state: &ExceptionState) -> Result<Node, String> {
    self.html_element.element.node.insert_before(new_child, ref_child, exception_state)
  }
  fn is_equal_node(&self, other_node: &Node, exception_state: &ExceptionState) -> Result<bool, String> {
    self.html_element.element.node.is_equal_node(other_node, exception_state)
  }
  fn is_same_node(&self, other_node: &Node, exception_state: &ExceptionState) -> Result<bool, String> {
    self.html_element.element.node.is_same_node(other_node, exception_state)
  }
  fn remove_child(&self, old_child: &Node, exception_state: &ExceptionState) -> Result<Node, String> {
    self.html_element.element.node.remove_child(old_child, exception_state)
  }
  fn remove(&self, exception_state: &ExceptionState) -> Result<(), String> {
    self.html_element.element.node.remove(exception_state)
  }
  fn replace_child(&self, new_child: &Node, old_child: &Node, exception_state: &ExceptionState) -> Result<Node, String> {
    self.html_element.element.node.replace_child(new_child, old_child, exception_state)
  }
  fn as_node(&self) -> &Node {
    &self.html_element.element.node
  }
}
impl EventTargetMethods for HTMLImageElement {
  fn add_event_listener(&self, type_: &str, callback: EventListenerCallback, options: &AddEventListenerOptions, exception_state: &ExceptionState) -> Result<(), String> {
    self.html_element.element.node.event_target.add_event_listener(type_, callback, options, exception_state)
  }
  fn remove_event_listener(&self, type_: &str, callback: EventListenerCallback, options: &EventListenerOptions, exception_state: &ExceptionState) -> Result<(), String> {
    self.html_element.element.node.event_target.remove_event_listener(type_, callback, options, exception_state)
  }
  fn dispatch_event(&self, event: &Event, exception_state: &ExceptionState) -> Result<bool, String> {
    self.html_element.element.node.event_target.dispatch_event(event, exception_state)
  }
  fn as_event_target(&self) -> &EventTarget {
    &self.html_element.element.node.event_target
  }
}

import 'dart:convert';
import 'dart:io';

/// Generates two files from `lucide_icons_flutter` package:
/// 1) TypeScript declaration file (lib/src/lucide_icons.d.ts)
///    exporting a string-valued enum `LucideIcons` with an entry for each
///    static IconData defined (base icons only, without stroke width variants).
/// 2) Dart map file (lib/src/lucide_icons_map_generated.dart)
///    mapping string icon names to `LucideIcons.<name>` values for runtime lookup.
///
/// Usage:
///   dart run tool/generate_lucide_icons.dart
///     - Discovers lucide_icons_flutter via pub cache and reads lucide_icons.dart
///     - Writes lib/src/lucide_icons.d.ts and lib/src/lucide_icons_map_generated.dart
Future<void> main(List<String> args) async {
  // Resolve input path from pub cache
  String inputPath;
  if (args.isNotEmpty) {
    inputPath = args[0];
  } else {
    final pubCachePath = await _findPubCachePath();
    if (pubCachePath == null) {
      stderr.writeln('Unable to locate pub cache.');
      stderr.writeln('Pass the path to lucide_icons.dart explicitly as the first argument.');
      exitCode = 2;
      return;
    }

    // Find lucide_icons_flutter package
    final lucideDir = Directory('$pubCachePath/hosted/pub.dev')
        .listSync()
        .whereType<Directory>()
        .where((d) => d.path.contains('lucide_icons_flutter'))
        .toList();

    if (lucideDir.isEmpty) {
      stderr.writeln('lucide_icons_flutter not found in pub cache.');
      stderr.writeln('Run "flutter pub get" first to download the package.');
      exitCode = 2;
      return;
    }

    // Sort to get the latest version
    lucideDir.sort((a, b) => b.path.compareTo(a.path));
    inputPath = '${lucideDir.first.path}/lib/lucide_icons.dart';
  }

  // Default output paths inside this package.
  final outputDtsPath = 'lib/src/lucide_icons.d.ts';
  final outputDartMapPath = 'lib/src/lucide_icons_map_generated.dart';

  final file = File(inputPath);
  if (!await file.exists()) {
    stderr.writeln('Input file not found: $inputPath');
    exitCode = 2;
    return;
  }

  final content = await file.readAsString();

  // Extract all static const IconData names defined in class LucideIcons.
  // We match any line like: `static const IconData name = ...;`
  // but exclude those ending with 100-600 (stroke width variants)
  final iconNameRe = RegExp(
    r'static\s+const\s+IconData\s+(\w+)\s*=\s*',
    multiLine: true,
  );

  final strokeWidthVariantRe = RegExp(r'^\w+(100|200|300|400|500|600)$');

  final Set<String> names = <String>{};
  for (final m in iconNameRe.allMatches(content)) {
    final name = m.group(1);
    if (name == null) continue;
    // Exclude private names if any slipped in (shouldn't, but be safe).
    if (name.startsWith('_')) continue;
    // Exclude stroke width variants (ending with 100-600)
    if (strokeWidthVariantRe.hasMatch(name)) continue;
    names.add(name);
  }

  if (names.isEmpty) {
    stderr.writeln('No IconData names found in: $inputPath');
    exitCode = 3;
    return;
  }

  final sorted = names.toList()
    ..sort((a, b) => a.toLowerCase().compareTo(b.toLowerCase()));

  // 1) Write .d.ts keys
  final StringBuffer outDts = StringBuffer();
  outDts.writeln('// Generated by tool/generate_lucide_icons.dart');
  outDts.writeln('// Do not edit by hand.');
  outDts.writeln();
  outDts.writeln('declare enum LucideIcons {');
  for (final name in sorted) {
    outDts.writeln('  $name = ${jsonEncode(name)},');
  }
  outDts.writeln('}');
  outDts.writeln();
  await File(outputDtsPath).writeAsString(outDts.toString());

  // 2) Write Dart map for lookup in runtime
  final StringBuffer outDart = StringBuffer();
  outDart.writeln('// AUTO GENERATED FILE, DO NOT EDIT.');
  outDart.writeln('//');
  outDart.writeln('// Generated by tool/generate_lucide_icons.dart');
  outDart.writeln("import 'package:flutter/widgets.dart';");
  outDart.writeln("import 'package:lucide_icons_flutter/lucide_icons.dart';");
  outDart.writeln();
  outDart.writeln('const Map<String, IconData> kLucideIconMap = {');
  for (final name in sorted) {
    outDart.writeln("  '$name': LucideIcons.$name,");
  }
  outDart.writeln('};');
  outDart.writeln();
  outDart.writeln('/// Returns the IconData for the given icon name and optional stroke width.');
  outDart.writeln('/// Stroke width should be one of: 100, 200, 300, 400, 500, 600');
  outDart.writeln('/// If stroke width is null or not a valid variant, returns the base icon.');
  outDart.writeln('IconData? getLucideIcon(String name, [int? strokeWidth]) {');
  outDart.writeln('  if (strokeWidth != null && [100, 200, 300, 400, 500, 600].contains(strokeWidth)) {');
  outDart.writeln('    final variantName = \'\$name\$strokeWidth\';');
  outDart.writeln('    final variantIcon = kLucideIconVariantMap[variantName];');
  outDart.writeln('    if (variantIcon != null) return variantIcon;');
  outDart.writeln('  }');
  outDart.writeln('  return kLucideIconMap[name];');
  outDart.writeln('}');
  outDart.writeln();
  outDart.writeln('const Map<String, IconData> kLucideIconVariantMap = {');
  for (final name in sorted) {
    for (final variant in [100, 200, 300, 400, 500, 600]) {
      outDart.writeln("  '${name}$variant': LucideIcons.${name}$variant,");
    }
  }
  outDart.writeln('};');
  outDart.writeln();
  await File(outputDartMapPath).writeAsString(outDart.toString());

  stdout.writeln('Wrote $outputDtsPath and $outputDartMapPath with ${sorted.length} base icons.');
}

Future<String?> _findPubCachePath() async {
  // Check PUB_CACHE environment variable first
  final env = Platform.environment['PUB_CACHE'];
  if (env != null && env.isNotEmpty) {
    final dir = Directory(env);
    if (await dir.exists()) return dir.path;
  }

  // Default locations
  if (Platform.isWindows) {
    final appData = Platform.environment['APPDATA'];
    if (appData != null) {
      final dir = Directory('$appData/Pub/Cache');
      if (await dir.exists()) return dir.path;
    }
  } else {
    final home = Platform.environment['HOME'];
    if (home != null) {
      final dir = Directory('$home/.pub-cache');
      if (await dir.exists()) return dir.path;
    }
  }

  return null;
}

name: Release WebF Package

# Trigger only when a new release is published
on:
  release:
    types: [published]
  workflow_dispatch:

jobs:
  # Build bridge binaries for each platform
  build-windows:
    name: Build Windows Bridge
    runs-on: windows-latest

    env:
      nodeVersion: "22"
      cmakeVersion: "3.28.1"

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: recursive

      - name: Setup CMake
        uses: jwlawson/actions-setup-cmake@v2
        with:
          cmake-version: ${{ env.cmakeVersion }}

      - name: Setup MSYS2
        uses: msys2/setup-msys2@v2
        with:
          msystem: UCRT64
          update: true
          install: >-
            mingw-w64-ucrt-x86_64-toolchain
            mingw-w64-ucrt-x86_64-clang
            mingw-w64-ucrt-x86_64-clang-tools-extra
            mingw-w64-ucrt-x86_64-libc++
            mingw-w64-ucrt-x86_64-cmake
            mingw-w64-ucrt-x86_64-ninja
            mingw-w64-ucrt-x86_64-pkgconf
            mingw-w64-ucrt-x86_64-gperf
            mingw-w64-ucrt-x86_64-icu
            mingw-w64-ucrt-x86_64-libiconv
            mingw-w64-ucrt-x86_64-winpthreads
            git
            make
            curl
            unzip

      - name: Add MSYS2 to PATH
        shell: bash
        run: |
          echo "C:/msys64/ucrt64/bin" >> $GITHUB_PATH
          echo "C:/msys64/usr/bin" >> $GITHUB_PATH

      - name: Install NVM and Node.js
        shell: msys2 {0}
        run: |
          # Unset npm_config_prefix to avoid NVM conflicts
          unset npm_config_prefix

          # Install NVM
          curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash

          # Source nvm
          export NVM_DIR="$HOME/.nvm"
          [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"

          # Install and use Node.js
          nvm install ${{ env.nodeVersion }}
          nvm use ${{ env.nodeVersion }}
          nvm alias default ${{ env.nodeVersion }}

          # Verify installation
          node --version
          npm --version

      - name: Verify toolchain
        shell: bash
        run: |
          which clang
          which clang++
          clang --version
          cmake --version
          ninja --version

      - name: Install Node.js dependencies
        shell: msys2 {0}
        run: |
          unset npm_config_prefix
          export NVM_DIR="$HOME/.nvm"
          [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
          npm install

      - name: Generate binding code
        shell: msys2 {0}
        run: |
          unset npm_config_prefix
          export NVM_DIR="$HOME/.nvm"
          [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
          npm run bindgen

      - name: Build Windows bridge
        shell: msys2 {0}
        run: |
          echo "ğŸ”¨ Building Windows bridge..."
          unset npm_config_prefix
          export NVM_DIR="$HOME/.nvm"
          [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
          export CC=clang
          export CXX=clang++
          export WEBF_BUILD=Release
          export WEBF_JS_ENGINE=quickjs
          # Set MSYS2 paths for CMake - use Windows-style paths for CMake
          export MSYSTEM_PREFIX="D:/a/_temp/msys64/ucrt64"
          export MINGW_64="D:/a/_temp/msys64/ucrt64"

          echo "Using MSYSTEM_PREFIX: $MSYSTEM_PREFIX"
          echo "Using MINGW_64: $MINGW_64"

          # Verify MSYS2 installation path
          ls -la /d/a/_temp/msys64/ucrt64/bin/ || echo "MSYS2 path not found, checking alternatives..."

          npm run build:bridge:windows:release
        env:
          WEBF_BUILD: Release
          WEBF_JS_ENGINE: quickjs

      - name: Run Bridge Unit Tests
        shell: powershell
        run: |
          node scripts/run_bridge_unit_test.js

      - name: Prepare Windows debug symbols
        shell: msys2 {0}
        run: |
          # Create debug symbols directory for artifact upload
          mkdir -p debug-symbols-windows

          # Find and copy debug symbol files from Windows build directory
          echo "ğŸ” Searching for debug symbols in bridge/build/windows..."

          # Copy .debug files (extracted debug symbols from objcopy)
          find bridge/build/windows -name "*.debug" -type f -exec cp {} debug-symbols-windows/ \; 2>/dev/null || true

          # Copy any PDB files if they exist
          find bridge/build/windows -name "*.pdb" -type f -exec cp {} debug-symbols-windows/ \; 2>/dev/null || true

          # Count files found
          debug_count=$(find debug-symbols-windows -type f | wc -l)
          echo "Found $debug_count debug symbol files"

          if [ "$debug_count" -gt 0 ]; then
            echo "ğŸ“‹ Debug symbols prepared for upload:"
            ls -lh debug-symbols-windows/
          else
            echo "âš ï¸  No debug symbols found"
          fi

      - name: Upload Windows debug symbols artifact
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: debug-symbols-windows
          path: debug-symbols-windows/
          retention-days: 1
          if-no-files-found: warn

      - name: Upload Windows binaries
        uses: actions/upload-artifact@v4
        with:
          name: windows-binaries
          path: |
            bridge/build/windows/lib/*.dll
            bridge/build/windows/lib/webf_unit_test.exe
          retention-days: 1
          if-no-files-found: warn

  build-linux:
    name: Build Linux Bridge
    runs-on: ubuntu-latest

    env:
      nodeVersion: "22"
      cmakeVersion: "3.28.1"

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: recursive

      - name: Setup CMake
        uses: jwlawson/actions-setup-cmake@v2
        with:
          cmake-version: ${{ env.cmakeVersion }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.nodeVersion }}
          cache: 'npm'

      - name: Install build dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential \
            ninja-build \
            clang \
            libc++-dev \
            libc++abi-dev \
            chrpath \
            gperf \
            patchelf \
            pkg-config \
            openjdk-17-jdk \
            libiconv-hook-dev \
            libicu-dev

      - name: Verify toolchain
        run: |
          which clang
          which clang++
          clang --version
          clang++ --version
          cmake --version
          ninja --version
          chrpath --version
          gperf --version

      - name: Install Node.js dependencies
        run: npm ci

      - name: Generate binding code
        run: npm run bindgen

      - name: Build Linux bridge
        run: |
          echo "ğŸ”¨ Building Linux bridge..."
          export CC=clang
          export CXX=clang++
          export WEBF_BUILD=Release
          export WEBF_JS_ENGINE=quickjs
          npm run build:bridge:linux:release
        env:
          CC: clang
          CXX: clang++
          WEBF_BUILD: Release
          WEBF_JS_ENGINE: quickjs

      - name: Run Bridge Unit Tests
        run: |
          node scripts/run_bridge_unit_test.js

      - name: Upload Linux binaries
        uses: actions/upload-artifact@v4
        with:
          name: linux-binaries
          path: |
            bridge/build/linux/lib/*.so
            bridge/build/linux/lib/webf_unit_test
          retention-days: 1
          if-no-files-found: warn

      - name: Upload Linux debug symbols
        uses: actions/upload-artifact@v4
        with:
          name: debug-symbols-linux
          path: |
            bridge/build/linux/lib/*.debug
          retention-days: 1
          if-no-files-found: warn

  build-macos:
    name: Build macOS Bridge
    runs-on: [self-hosted, macos]

    env:
      nodeVersion: "22"
      cmakeVersion: "3.28.1"

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: recursive

      - name: Setup CMake
        uses: jwlawson/actions-setup-cmake@v2
        with:
          cmake-version: ${{ env.cmakeVersion }}

      # - name: Setup Node.js
      #   uses: actions/setup-node@v4
      #   with:
      #     node-version: ${{ env.nodeVersion }}
      #     cache: 'npm'

      - name: Install build dependencies
        run: |
          # Check if ninja is already installed on self-hosted runner
          which ninja || brew install ninja

      - name: Verify toolchain
        run: |
          which clang
          which clang++
          clang --version
          cmake --version
          ninja --version

      - name: Install Node.js dependencies
        run: npm ci

      - name: Generate binding code
        run: npm run bindgen

      - name: Build macOS bridge
        run: |
          echo "ğŸ”¨ Building macOS bridge..."
          export CC=clang
          export CXX=clang++
          export WEBF_BUILD=Release
          export WEBF_JS_ENGINE=quickjs
          npm run build:bridge:macos:release
        env:
          CC: clang
          CXX: clang++
          WEBF_BUILD: Release
          WEBF_JS_ENGINE: quickjs

      - name: Run Bridge Unit Tests
        run: |
          node scripts/run_bridge_unit_test.js

      - name: Prepare macOS debug symbols
        run: |
          # Create debug symbols directory for artifact upload
          mkdir -p debug-symbols-macos

          # Find and copy dSYM directories from macOS build
          echo "ğŸ” Searching for debug symbols in bridge/build/macos..."

          # Find and copy dSYM bundles (preserving directory structure)
          find bridge/build/macos -name "*.dSYM" -type d | while read dsym; do
            # Get relative path from bridge/build/macos
            rel_path=${dsym#bridge/build/macos/}
            # Create parent directory in destination
            mkdir -p "debug-symbols-macos/$(dirname "$rel_path")"
            # Copy entire dSYM bundle
            cp -R "$dsym" "debug-symbols-macos/$(dirname "$rel_path")/"
          done

          # Count dSYM bundles found
          dsym_count=$(find debug-symbols-macos -name "*.dSYM" -type d | wc -l)
          echo "Found $dsym_count dSYM bundles"

          if [ "$dsym_count" -gt 0 ]; then
            echo "ğŸ“‹ Debug symbols prepared for upload:"
            find debug-symbols-macos -name "*.dSYM" -type d
          else
            echo "âš ï¸  No debug symbols found"
          fi

      - name: Upload macOS debug symbols artifact
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: debug-symbols-macos
          path: debug-symbols-macos/
          retention-days: 1
          if-no-files-found: warn

      - name: Upload macOS binaries
        uses: actions/upload-artifact@v4
        with:
          name: macos-binaries
          path: |
            bridge/build/macos/lib/*.dylib
            bridge/build/macos/lib/webf_unit_test
            bridge/build/macos/
          retention-days: 1
          if-no-files-found: warn

  build-ios:
    name: Build iOS Bridge
    runs-on: [self-hosted, macos]

    env:
      nodeVersion: "22"
      cmakeVersion: "3.28.1"

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: recursive

      - name: Setup CMake
        uses: jwlawson/actions-setup-cmake@v2
        with:
          cmake-version: ${{ env.cmakeVersion }}

      # - name: Setup Node.js
      #   uses: actions/setup-node@v4
      #   with:
      #     node-version: ${{ env.nodeVersion }}
      #     cache: 'npm'

      - name: Verify toolchain
        run: |
          xcodebuild -version
          which clang
          clang --version

      - name: Install Node.js dependencies
        run: npm install

      - name: Generate binding code
        run: npm run bindgen

      - name: Build iOS bridge
        run: |
          echo "ğŸ”¨ Building iOS bridge..."
          export WEBF_BUILD=Release
          export WEBF_JS_ENGINE=quickjs
          # Ensure dSYMs are created but not embedded in Release builds
          export INCLUDE_DSYMS_IN_XCFRAMEWORK=false
          npm run build:bridge:ios:release
        env:
          WEBF_BUILD: Release
          WEBF_JS_ENGINE: quickjs
          INCLUDE_DSYMS_IN_XCFRAMEWORK: false

      - name: Upload iOS binaries
        uses: actions/upload-artifact@v4
        with:
          name: ios-binaries
          path: |
            bridge/build/ios/framework/**/*.xcframework
          retention-days: 1
          if-no-files-found: warn

      - name: Upload iOS debug symbols
        uses: actions/upload-artifact@v4
        with:
          name: debug-symbols-ios
          path: |
            bridge/build/ios/framework/**/*.dSYMs/
          retention-days: 1
          if-no-files-found: warn

  build-android:
    name: Build Android Bridge
    runs-on: [self-hosted, macos]

    env:
      nodeVersion: "22"
      cmakeVersion: "3.28.1"

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: recursive

      - name: Setup CMake
        uses: jwlawson/actions-setup-cmake@v2
        with:
          cmake-version: ${{ env.cmakeVersion }}

      # - name: Setup Node.js
      #   uses: actions/setup-node@v4
      #   with:
      #     node-version: ${{ env.nodeVersion }}
      #     cache: 'npm'

      - name: Setup Android SDK and NDK
        uses: nttld/setup-ndk@v1
        id: setup-ndk
        with:
          ndk-version: r27d
        env:
          ANDROID_NDK_HOME: ${{ steps.setup-ndk.outputs.ndk-path }}

      - name: Setup build dependencies
        run: |
          # Check if build tools are already installed on self-hosted macOS runner
          which ninja || brew install ninja
          which pkg-config || brew install pkg-config

      - name: Verify toolchain
        run: |
          which clang
          clang --version
          cmake --version
          ninja --version
          echo "Android SDK: $ANDROID_HOME"
          echo "Android NDK: ${{ steps.setup-ndk.outputs.ndk-path }}"
          ls -la "${{ steps.setup-ndk.outputs.ndk-path }}" || echo "NDK directory not found"

      - name: Install Node.js dependencies
        run: npm ci

      - name: Generate binding code
        run: npm run bindgen

      - name: Build Android bridge
        env:
          ANDROID_NDK_HOME: ${{ steps.setup-ndk.outputs.ndk-path }}
          ANDROID_NDK_ROOT: ${{ steps.setup-ndk.outputs.ndk-path }}
          WEBF_BUILD: Release
          WEBF_JS_ENGINE: quickjs
        run: |
          echo "ğŸ”¨ Building Android bridge..."
          echo "Using NDK: $ANDROID_NDK_HOME"
          echo "NDK version: ${{ steps.setup-ndk.outputs.ndk-full-version }}"
          export WEBF_BUILD=Release
          export WEBF_JS_ENGINE=quickjs
          npm run build:bridge:android:release

      - name: Prepare Android debug symbols
        run: |
          # Create debug symbols directory for artifact upload with architecture subdirectories
          mkdir -p debug-symbols-android

          # Find and copy debug symbol files from Android build directory, preserving architecture structure
          echo "ğŸ” Searching for debug symbols in bridge/build/android/lib/..."

          # Copy .debug files while preserving the architecture directory structure
          for arch in arm64-v8a armeabi-v7a x86 x86_64; do
            if [ -d "bridge/build/android/lib/$arch" ]; then
              mkdir -p "debug-symbols-android/$arch"
              find "bridge/build/android/lib/$arch" -name "*.debug" -type f -exec cp {} "debug-symbols-android/$arch/" \; 2>/dev/null || true
            fi
          done

          # Count files found
          debug_count=$(find debug-symbols-android -type f -name "*.debug" | wc -l)
          echo "Found $debug_count debug symbol files"

          if [ "$debug_count" -gt 0 ]; then
            echo "ğŸ“‹ Debug symbols prepared for upload by architecture:"
            for arch in arm64-v8a armeabi-v7a x86 x86_64; do
              if [ -d "debug-symbols-android/$arch" ]; then
                count=$(find "debug-symbols-android/$arch" -type f | wc -l)
                if [ "$count" -gt 0 ]; then
                  echo "  - $arch: $count files"
                  ls -lh "debug-symbols-android/$arch/"
                fi
              fi
            done
          else
            echo "âš ï¸  No debug symbols found"
          fi

      - name: Upload Android debug symbols artifact
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: debug-symbols-android
          path: debug-symbols-android/
          retention-days: 1
          if-no-files-found: warn

      - name: Upload Android binaries
        uses: actions/upload-artifact@v4
        with:
          name: android-binaries
          path: |
            bridge/build/android/**/*.so
            bridge/build/android/**/*.a
            bridge/build/android/
          retention-days: 1
          if-no-files-found: warn

  collect-debug-symbols:
    name: Collect and Upload Debug Symbols to LFS
    runs-on: ubuntu-latest
    # Wait for all bridge builds to complete
    needs: [build-windows, build-linux, build-macos, build-ios, build-android]

    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Git LFS
        run: |
          git lfs install
          git config --local user.email "actions@github.com"
          git config --local user.name "GitHub Actions"

      - name: Download all debug symbol artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: debug-symbols-*
          path: ./debug-artifacts

      - name: Install 7-Zip
        run: |
          sudo apt-get update
          sudo apt-get install -y p7zip-full

      - name: Organize and compress debug symbols
        run: |
          echo "ğŸ” Organizing and compressing debug symbols for release ${{ github.event.release.tag_name }}..."

          # Create temporary directory for organizing symbols
          mkdir -p temp-symbols/${{ github.event.release.tag_name }}

          # Process Windows debug symbols
          if [ -d "debug-artifacts/debug-symbols-windows" ]; then
            mkdir -p temp-symbols/${{ github.event.release.tag_name }}/windows
            cp -r debug-artifacts/debug-symbols-windows/* temp-symbols/${{ github.event.release.tag_name }}/windows/ 2>/dev/null || true
            echo "âœ… Windows debug symbols organized"
          fi

          # Process Linux debug symbols
          if [ -d "debug-artifacts/debug-symbols-linux" ]; then
            mkdir -p temp-symbols/${{ github.event.release.tag_name }}/linux
            cp -r debug-artifacts/debug-symbols-linux/* temp-symbols/${{ github.event.release.tag_name }}/linux/ 2>/dev/null || true
            echo "âœ… Linux debug symbols organized"
          fi

          # Process macOS debug symbols
          if [ -d "debug-artifacts/debug-symbols-macos" ]; then
            mkdir -p temp-symbols/${{ github.event.release.tag_name }}/macos
            cp -r debug-artifacts/debug-symbols-macos/* temp-symbols/${{ github.event.release.tag_name }}/macos/ 2>/dev/null || true
            echo "âœ… macOS debug symbols organized"
          fi

          # Process iOS debug symbols
          if [ -d "debug-artifacts/debug-symbols-ios" ]; then
            mkdir -p temp-symbols/${{ github.event.release.tag_name }}/ios
            cp -r debug-artifacts/debug-symbols-ios/* temp-symbols/${{ github.event.release.tag_name }}/ios/ 2>/dev/null || true
            echo "âœ… iOS debug symbols organized"
          fi

          # Process Android debug symbols
          if [ -d "debug-artifacts/debug-symbols-android" ]; then
            mkdir -p temp-symbols/${{ github.event.release.tag_name }}/android
            cp -r debug-artifacts/debug-symbols-android/* temp-symbols/${{ github.event.release.tag_name }}/android/ 2>/dev/null || true
            echo "âœ… Android debug symbols organized"
          fi

          # Create compressed archives for each platform
          mkdir -p debug-symbols/${{ github.event.release.tag_name }}

          for platform in windows linux macos ios android; do
            if [ -d "temp-symbols/${{ github.event.release.tag_name }}/$platform" ]; then
              echo "ğŸ“¦ Compressing $platform debug symbols..."

              # Count files before compression
              file_count=$(find temp-symbols/${{ github.event.release.tag_name }}/$platform -type f | wc -l)

              if [ "$file_count" -gt 0 ]; then
                # Get size before compression
                size_before=$(du -sh temp-symbols/${{ github.event.release.tag_name }}/$platform | cut -f1)

                # Compress with 7z using maximum compression
                7z a -t7z -m0=lzma2 -mx=9 -mfb=64 -md=32m -ms=on \
                  debug-symbols/${{ github.event.release.tag_name }}/${platform}-debug-symbols.7z \
                  temp-symbols/${{ github.event.release.tag_name }}/$platform/* > /dev/null

                # Get size after compression
                size_after=$(du -sh debug-symbols/${{ github.event.release.tag_name }}/${platform}-debug-symbols.7z | cut -f1)

                echo "  âœ… $platform: $file_count files, $size_before â†’ $size_after"
              fi
            fi
          done

          # Count total compressed archives
          total_archives=$(find debug-symbols/${{ github.event.release.tag_name }} -name "*.7z" -type f | wc -l)
          echo "ğŸ“Š Total compressed debug symbol archives: $total_archives"

          if [ "$total_archives" -gt 0 ]; then
            # List all compressed debug symbols
            echo "ğŸ“‹ Compressed debug symbols summary:"
            ls -lh debug-symbols/${{ github.event.release.tag_name }}/*.7z 2>/dev/null

            # Calculate total compression ratio
            original_size=$(du -sh temp-symbols/${{ github.event.release.tag_name }} 2>/dev/null | cut -f1)
            compressed_size=$(du -sh debug-symbols/${{ github.event.release.tag_name }} | cut -f1)
            echo "ğŸ’¾ Total size: $original_size â†’ $compressed_size"

            # Setup Git LFS tracking for 7z files if not already done
            if ! grep -q "debug-symbols/\*\*/\*\.7z.*filter=lfs" .gitattributes; then
              git lfs track "debug-symbols/**/*.7z"
            fi

            # Add all debug symbols
            git add .gitattributes
            git add debug-symbols/

            # Get the current branch name for the release
            CURRENT_BRANCH=${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}
            echo "ğŸ“‹ Target branch: $CURRENT_BRANCH"

            # Commit compressed debug symbols
            git commit -m "Add compressed debug symbols for release ${{ github.event.release.tag_name }} (7z archives)"

            # Push to the release branch
            git push origin HEAD:$CURRENT_BRANCH
            echo "âœ… Successfully uploaded compressed debug symbols to Git LFS on branch: $CURRENT_BRANCH"

            # Clean up temporary files
            rm -rf temp-symbols/
            echo "ğŸ§¹ Cleaned up temporary files"
          else
            echo "âš ï¸  No debug symbols found to upload"
          fi

  prepare-and-publish:
    name: Prepare and Publish WebF Package
    runs-on: ubuntu-latest
    # Wait for all bridge builds and debug symbol collection
    needs: [build-windows, build-linux, build-macos, build-ios, build-android, collect-debug-symbols]

    permissions:
      contents: write
      packages: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # Fetch full history for git operations
          fetch-depth: 0
          # Use a personal access token to allow pushing to webf directory
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: '3.19.0'
          channel: 'stable'

      - name: Setup Git configuration
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"

      - name: Download all build artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./artifacts
        continue-on-error: false

      - name: Restore bridge binaries
        run: |
          echo "ğŸ“¦ Restoring bridge binaries from artifacts..."

          # Create bridge/build directory structure
          mkdir -p bridge/build

          # Track restoration status
          RESTORE_FAILED=false

          # Restore Windows binaries
          if [ -d "artifacts/windows-binaries" ]; then
            cp -r artifacts/windows-binaries bridge/build/windows
            echo "âœ… Windows binaries restored"
          else
            echo "âš ï¸ Windows binaries not found"
            RESTORE_FAILED=true
          fi

          # Restore Linux binaries
          if [ -d "artifacts/linux-binaries" ]; then
            cp -r artifacts/linux-binaries bridge/build/linux
            echo "âœ… Linux binaries restored"
          else
            echo "âš ï¸ Linux binaries not found"
            RESTORE_FAILED=true
          fi

          # Restore macOS binaries
          if [ -d "artifacts/macos-binaries" ]; then
            cp -r artifacts/macos-binaries bridge/build/macos
            echo "âœ… macOS binaries restored"
          else
            echo "âš ï¸ macOS binaries not found"
            RESTORE_FAILED=true
          fi

          # Restore iOS binaries
          if [ -d "artifacts/ios-binaries" ]; then
            cp -r artifacts/ios-binaries bridge/build/ios
            echo "âœ… iOS binaries restored"
          else
            echo "âš ï¸ iOS binaries not found"
            RESTORE_FAILED=true
          fi

          # Restore Android binaries
          if [ -d "artifacts/android-binaries" ]; then
            cp -r artifacts/android-binaries bridge/build/android
            echo "âœ… Android binaries restored"
          else
            echo "âš ï¸ Android binaries not found"
            RESTORE_FAILED=true
          fi

          echo "ğŸ“‹ Bridge build directory structure:"
          find bridge/build -type f -name "*.so" -o -name "*.dll" -o -name "*.dylib" -o -name "*.a" -o -name "*.framework" | head -20

          # Exit with error if any platform binaries are missing
          if [ "$RESTORE_FAILED" = true ]; then
            echo "âŒ Error: Some platform binaries are missing. Please check the build jobs."
            exit 1
          fi

      - name: Prepare package for release
        run: |
          echo "ğŸ§¹ Preparing package for release..."
          npm run prepare-release

      - name: Copy prebuilt binaries to WebF package
        run: |
          echo "ğŸš€ Copying prebuilt binaries to WebF package..."

          # Windows binaries
          echo "ğŸ“¦ Windows binaries..."
          npm run use-prebuilt:windows || echo "âš ï¸ Windows binaries copy failed (may be expected on Linux)"

          # Linux binaries
          echo "ğŸ“¦ Linux binaries..."
          npm run use-prebuilt:linux

          # macOS binaries (skip on Linux CI, would fail)
          echo "ğŸ“¦ macOS binaries..."
          # Note: macOS script requires macOS platform, copy manually on Linux
          if [ -d "bridge/build/macos/lib/universal" ]; then
            mkdir -p webf/macos
            cp bridge/build/macos/lib/universal/*.dylib webf/macos/ 2>/dev/null || true
            echo "âœ… macOS binaries copied manually"
          fi

          # iOS binaries
          echo "ğŸ“¦ iOS binaries..."
          npm run use-prebuilt:ios

          # Android binaries
          echo "ğŸ“¦ Android binaries..."
          npm run use-prebuilt:android

          echo "âœ… All prebuilt binaries copied"

      - name: Verify prepared package
        run: |
          echo "ğŸ” Verifying prepared package structure..."

          # Check Linux libraries
          if ls webf/linux/*.so 1> /dev/null 2>&1; then
            echo "âœ… Linux libraries found:"
            ls -lh webf/linux/*.so
          else
            echo "âš ï¸ Linux libraries not found"
          fi

          # Check Windows libraries
          if ls webf/windows/*.dll 1> /dev/null 2>&1; then
            echo "âœ… Windows libraries found:"
            ls -lh webf/windows/*.dll
          else
            echo "âš ï¸ Windows libraries not found"
          fi

          # Check macOS libraries
          if ls webf/macos/*.dylib 1> /dev/null 2>&1; then
            echo "âœ… macOS libraries found:"
            ls -lh webf/macos/*.dylib
          else
            echo "âš ï¸ macOS libraries not found"
          fi

          # Check iOS frameworks
          if [ -d "webf/ios/Frameworks" ]; then
            echo "âœ… iOS frameworks found:"
            ls -la webf/ios/Frameworks/
          else
            echo "âš ï¸ iOS frameworks not found"
          fi

          # Check Android libraries
          if [ -d "webf/android/jniLibs" ]; then
            echo "âœ… Android JNI libraries found:"
            find webf/android/jniLibs -name "*.so" | head -10
          else
            echo "âš ï¸ Android JNI libraries not found"
          fi

      - name: Update WebF version
        run: |
          echo "ğŸ”¢ Updating WebF version to ${{ github.event.release.tag_name }}..."

          # Update version in pubspec.yaml
          cd webf
          # Remove 'v' prefix if present
          VERSION="${{ github.event.release.tag_name }}"
          VERSION="${VERSION#v}"

          # Update pubspec.yaml version
          sed -i "s/^version: .*/version: $VERSION/" pubspec.yaml

          echo "âœ… Updated version to $VERSION"

      - name: Authenticate Cloudsmith for WebF
        run: |
          echo "ğŸ” Setting up Cloudsmith authentication..."

          # Add the Cloudsmith token for the WebF repository
          echo '${{ secrets.CLOUDSMITH_API_KEY }}' | dart pub token add https://dart.cloudsmith.io/openwebf/packages/

          echo "âœ… Cloudsmith authentication configured"

      - name: Publish to Cloudsmith
        run: |
          echo "ğŸš€ Publishing WebF to Cloudsmith..."

          cd webf

          # Run Flutter pub get to ensure dependencies are resolved
          flutter pub get

          # Publish to Cloudsmith repository
          dart pub publish

          echo "âœ… Successfully published WebF version ${{ github.event.release.tag_name }} to Cloudsmith"

      - name: Summary
        run: |
          echo "ğŸ‰ WebF package published successfully!"
          echo "ğŸ“‹ Summary:"
          echo "   - Release: ${{ github.event.release.tag_name }}"
          echo "   - Commit: ${{ github.sha }}"
          echo "   - Published to: Cloudsmith (https://dart.cloudsmith.io/openwebf/packages/)"
          echo "   - Debug symbols stored in Git LFS"

  create-pr-to-main:
    name: Create PR to Main Branch
    runs-on: ubuntu-latest
    needs: [prepare-and-publish]
    if: success()

    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Git configuration
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"

      - name: Extract version and branch info
        id: version-info
        run: |
          # Remove 'v' prefix if present from tag name
          VERSION="${{ github.event.release.tag_name }}"
          VERSION="${VERSION#v}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          
          # Determine the release branch name
          RELEASE_BRANCH="release/$VERSION"
          echo "release_branch=$RELEASE_BRANCH" >> $GITHUB_OUTPUT
          
          echo "ğŸ“‹ Version: $VERSION"
          echo "ğŸ“‹ Release branch: $RELEASE_BRANCH"

      - name: Create Pull Request to main
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Fetch latest changes
          git fetch origin
          
          # Check if PR already exists
          EXISTING_PR=$(gh pr list --base main --head "${{ steps.version-info.outputs.release_branch }}" --state open --json number --jq '.[0].number' || echo "")
          
          if [ -n "$EXISTING_PR" ]; then
            echo "âœ… Pull request #$EXISTING_PR already exists"
            echo "ğŸ“‹ PR URL: https://github.com/${{ github.repository }}/pull/$EXISTING_PR"
          else
            echo "ğŸ“ Creating pull request from ${{ steps.version-info.outputs.release_branch }} to main..."
            
            # Create the pull request
            PR_URL=$(gh pr create \
              --base main \
              --head "${{ steps.version-info.outputs.release_branch }}" \
              --title "Release ${{ github.event.release.tag_name }}" \
              --body "$(cat <<'EOF'
## ğŸš€ Release ${{ github.event.release.tag_name }}

This pull request merges the release branch back to the main branch after successful package publication.

### ğŸ“‹ Release Information
- **Version**: ${{ github.event.release.tag_name }}
- **Release URL**: ${{ github.event.release.html_url }}
- **Published to**: [Cloudsmith](https://dart.cloudsmith.io/openwebf/packages/)

### âœ… Automated Checks Completed
- All platform bridges built successfully
- Debug symbols collected and stored in Git LFS
- Package published to Cloudsmith

### ğŸ“ Merge Checklist
- [ ] Review the changes in this release
- [ ] Verify package is available on Cloudsmith
- [ ] Confirm all CI checks pass

---
*This PR was automatically created by the release workflow.*
EOF
              )")
            
            echo "âœ… Pull request created successfully!"
            echo "ğŸ“‹ PR URL: $PR_URL"
          fi

      - name: Add summary to workflow
        run: |
          echo "## ğŸ“‹ Release Workflow Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### âœ… Release Published" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: ${{ github.event.release.tag_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Package**: Published to [Cloudsmith](https://dart.cloudsmith.io/openwebf/packages/)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ”„ Pull Request" >> $GITHUB_STEP_SUMMARY
          echo "A pull request has been created to merge the release changes back to main branch." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Please review and merge the PR to complete the release process." >> $GITHUB_STEP_SUMMARY
